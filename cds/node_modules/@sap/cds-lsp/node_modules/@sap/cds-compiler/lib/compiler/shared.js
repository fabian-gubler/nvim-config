// Compiler functions and utilities shared across all phases
// TODO: rename to paths.js and move non resolve-paths functions to somewhere else

'use strict';

const { CompilerAssertion } = require('../base/error');
const { searchName } = require('../base/messages');

const {
  setLink,
  setArtifactLink,
  dependsOn,
  pathName,
  userQuery,
  definedViaCdl,
} = require('./utils');

/**
 * Main export function of this file.  Attach "resolve" functions shared for phase
 * "define" and "resolve" to `model.$functions`, where argument `model` is the XSN.
 *
 * Before calling `resolvePath`, make sure that the following function
 * in model.$function is set:
 * - `navigationEnv`: a function which returns the search environment defined by
 *    its argument, e.g. a function which returns the dictionary of subartifacts.
 *
 * @param {XSN.Model} model
 */
// TODO: yes, this function will be renamed
function fns( model ) {
  const { options } = model;
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  const Functions = model.$functions;

  const referenceSemantics = {
    // global: ------------------------------------------------------------------
    using: {                    // only used to produce error message
      isMainRef: 'all',
      lexical: null,
      dynamic: modelDefinitions,
      notFound: undefinedDefinition,
    },
    // only used for the main annotate/extend statements, not inner ones:
    annotate: {
      isMainRef: 'all',
      lexical: userBlock,
      dynamic: modelDefinitions,
      notFound: undefinedForAnnotate,
    },
    extend: {
      isMainRef: 'no-generated',
      lexical: userBlock,
      dynamic: modelDefinitions,
      notFound: undefinedDefinition,
    },
    _extensions: {
      isMainRef: 'all',
      lexical: userBlock,
      dynamic: modelDefinitions,
      notFound: false,          // without message
    },
    include: {
      isMainRef: 'no-generated',
      lexical: userBlock,
      dynamic: modelBuiltinsOrDefinitions,
      notFound: undefinedDefinition,
    },
    viewInclude: 'include',     // TODO: do differently
    target: {
      isMainRef: 'no-autoexposed',
      lexical: userBlock,
      dynamic: modelBuiltinsOrDefinitions,
      notFound: undefinedDefinition,
      // special `scope`s for redirections:
      global: () => ({ isMainRef: 'all', dynamic: modelDefinitions }),
    },
    targetAspect: {             // TODO: do differently
      isMainRef: 'no-autoexposed',
      lexical: userBlock,
      dynamic: modelBuiltinsOrDefinitions,
      notFound: undefinedDefinition,
    },
    from: {
      isMainRef: 'no-autoexposed',
      lexical: userBlock,
      dynamic: modelBuiltinsOrDefinitions,
      notFound: undefinedDefinition,
      navigation: environment,
    },
    type: {
      isMainRef: 'no-autoexposed',
      lexical: userBlock,
      dynamic: modelBuiltinsOrDefinitions,
      notFound: undefinedDefinition,
      navigation: targetAspectOnly,
      // special `scope`s for CDL parser - TYPE OF (TODO generated?), cds.Association:
      typeOf: typeOfSemantics,
      global: () => ({ isMainRef: 'no-autoexposed', dynamic: modelDefinitions }),
    },
    actionParamType: 'type',    // TODO: do differently
    eventType: 'type',          // TODO: do differently
    // element references without lexical scope (except $self/$projection): -----
    targetElement: {
      lexical: null,
      dollar: false,
      dynamic: targetElements,
      notFound: undefinedTargetElement,
      param: paramSemantics,
    },
    filter: {
      lexical: justDollarSelf,
      dollar: true,
      dynamic: targetElements,
      notFound: undefinedTargetElement,
      param: paramSemantics,
    },
    'calc-filter': {
      lexical: justDollarSelf,
      dollar: true,
      dynamic: targetElements,
      notFound: undefinedTargetElement,
      param: paramUnsupported,
    },
    default: {
      lexical: null,
      dollar: true,
      dynamic: () => Object.create( null ),
      notFound: undefinedVariable,
      param: paramUnsupported,
    },
    // general element references -----------------------------------------------
    expr: {                     // TODO: this is too general -> column
      lexical: tableAliasesIfNotExtendAndSelf,
      dollar: true,
      dynamic: combinedSourcesOrParentElements,
      notFound: undefinedSourceElement,
      param: paramSemantics,
      nestedColumn: () => ({       // in expand and inline
        lexical: justDollarSelf,
        dollar: true,
        dynamic: nestedElements,
        notFound: undefinedNestedElement,
        param: paramSemantics,
      }),
    },
    'param-only': {
      lexical: null,
      dollar: true,
      dynamic: () => Object.create( null ),
      notFound: undefinedVariable,
      param: paramSemantics,
    },
    calc: {
      lexical: justDollarSelf,
      dollar: true,
      dynamic: parentElements,
      notFound: undefinedParentElement,
      param: paramUnsupported,
    },
    joinOn: {
      lexical: tableAliasesAndSelf,
      dollar: true,
      dynamic: combinedSourcesOrParentElements, // TODO: source alone...
      notFound: undefinedSourceElement,
      param: paramSemantics,
    },
    on: {     // unmanaged assoc: outside query, redirected or new assoc in column
      lexical: justDollarSelf,
      allowBareSelf: true,
      dollar: true,
      dynamic: parentElements,
      notFound: undefinedParentElement,
      param: paramUnsupported,
      nestedColumn: () => ({       // in expand and inline
        lexical: justDollarSelf,
        dollar: true,
        dynamic: parentElements,
        notFound: undefinedParentElement,
      }),
    },
    'mixin-on': {
      lexical: tableAliasesAndSelf,
      allowBareSelf: true,
      dollar: true,
      dynamic: combinedSourcesOrParentElements,
      notFound: undefinedSourceElement,
      param: paramSemantics, // TODO: check that assocs containing param in ON is not published
    },
    'order-by-ref': {
      lexical: tableAliasesAndSelf,
      dollar: true,
      dynamic: parentElements,
      notFound: undefinedOrderByElement,
      param: paramSemantics,
    },
    'order-by-expr': {
      lexical: tableAliasesAndSelf,
      dollar: true,
      dynamic: combinedSourcesOrParentElements,
      notFound: undefinedSourceElement,
      param: paramSemantics,
    },
    'order-by-set-ref': {
      lexical: tableAliasesAndSelf, // TODO: reject own tab aliases
      dollar: true,
      dynamic: queryElements,
      notFound: undefinedParentElement,
      param: paramSemantics,
    },
    'order-by-set-expr': {
      lexical: tableAliasesAndSelf, // TODO: reject own tab aliases
      dollar: true,
      dynamic: () => Object.create( null ),
      notFound: undefinedVariable,
      param: paramSemantics,
    },
  };

  // TODO: combine envFn and assoc ?
  const specExpected = {
    using: {},                  // for using declaration
    // TODO: artifact references ---------------------------------------------
    extend: {},
    // ref in top-level EXTEND
    annotate: {},
    _extensions: {},
    type: { // TODO: more detailed later (e.g. for enum base type?)
      check: checkTypeRef,
      expectedMsgId: 'ref-expecting-type',
      sloppyMsgId: 'ref-sloppy-type',
    },
    actionParamType: {
      check: checkActionParamTypeRef,
      expectedMsgId: 'ref-expecting-action-param-type',
      sloppyMsgId: 'ref-sloppy-actionparam-type',
    },
    eventType: {
      check: checkEventTypeRef,
      expectedMsgId: 'ref-expecting-event-type',
      sloppyMsgId: 'ref-sloppy-event-type',
    },
    include: {
      check: checkIncludesRef,
      expectedMsgId: 'ref-expecting-struct',
    },
    viewInclude: {
      check: checkViewIncludesRef,
      expectedMsgId: 'ref-expecting-bare-aspect',
    },
    target: {
      check: checkEntityRef,
      expectedMsgId: 'ref-expecting-entity',
      noDep: true,
    },
    targetAspect: {
      check: checkTargetRef,
      expectedMsgId: 'ref-expecting-target',
      sloppyMsgId: 'ref-sloppy-target',
      noDep: 'only-entity',
    },
    from: {
      check: checkSourceRef,
      expectedMsgId: 'ref-expecting-source',
      assoc: 'from',
      argsSpec: 'expr',
    },
    // element references ----------------------------------------------------
    // TODO: dep for (explicit+implicit!) foreign keys
    // TODO: also check that we do not follow associations in foreign key? no args, no filter
    targetElement: { assoc: false },
    filter: {
      escape: 'param',
    },
    'calc-filter': {
      escape: 'param',
    },
    default: {
      check: checkConstRef,
      expectedMsgId: 'ref-expecting-const',
    },
    expr: {
      escape: 'param', assoc: 'nav',
    },
    'param-only': {
      escape: 'param',
    },
    calc: {
      assoc: 'nav',
    },
    joinOn: {                   // ON condition for JOIN: should be different to 'expr'!
      escape: 'param', assoc: 'nav',
    },
    on: {               // TODO: there will also be a 'from-on' (see 'expr')
      noDep: true,              // do not set dependency for circular-check
      allowSelf: true,
    }, // TODO: special assoc for only on user
    'mixin-on': {
      escape: 'param',    // TODO: extra check that assocs containing param in ON is not published
      noDep: true,              // do not set dependency for circular-check
      allowSelf: true,
    }, // TODO: special assoc for only on user
    // ---------marker for getPathRoot replaced-----------
    'order-by-ref': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      assoc: 'nav',
      dynamic: 'query',
      deprecatedSourceRefs: true,
    },
    'order-by-expr': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      assoc: 'nav',
    },
    'order-by-set-ref': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      noDep: true,
      dynamic: 'query',
      lexical: 'next',
    },
    'order-by-set-expr': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      noDep: true,
      dynamic: false,
      lexical: 'next',
    },
    // expr TODO: better - on condition for assoc, other on
    // expr TODO: write dependency, but care for $self
    param: {
      check: checkConstRef,
      expectedMsgId: 'ref-expecting-const',
    },
  };

  Object.assign( model.$functions, {
    resolveUncheckedPath,
    resolveTypeArgumentsUnchecked,
    resolvePath,
    attachAndEmitValidNames,
  } );
  return;

  function checkConstRef( art ) {
    return art.kind !== 'builtin' && art.kind !== 'param';
  }

  function checkIncludesRef( art ) {
    // We currently disallow using
    // - derived structure types: would have to follow type in extend/include;
    // - entities with params: clarify inheritance, use of param in ON/DEFAULT;
    // - query entities/events: difficult sequence of resolve steps
    // - aspect without elements (useful for actions/annotations)
    return !(art.elements && !art.query && !art.type && !art.params) && art.kind !== 'aspect';
  }

  /**
   * Returns true, if the given artifact can be included by a query entity / view.
   *
   * We currently allow:
   * - aspects without elements (the aspect may have actions):
   *   either no `elements` property or empty dictionary
   *
   * @param {XSN.Artifact} art
   * @return {boolean}
   */
  function checkViewIncludesRef( art ) {
    return !(art.kind === 'aspect' && (!art.elements || Object.keys(art.elements).length === 0));
  }

  /**
   * @returns {boolean|string}
   */
  function checkTypeRef( art ) {
    if (art.kind === 'type' || art.kind === 'element')
      return false;
    return ![ 'entity', 'aspect', 'event' ].includes( art.kind ) || 'sloppy';
  }

  /**
   * @returns {boolean|string}
   */
  function checkActionParamTypeRef( art ) {
    return !(art.kind === 'entity' && art._service) && checkTypeRef( art );
  }

  /**
   * @returns {boolean|string}
   */
  function checkEventTypeRef( art ) {
    return art.kind !== 'event' && checkActionParamTypeRef( art );
  }

  function checkEntityRef( art ) {
    return art.kind !== 'entity';
  }

  /**
   * @returns {boolean|string}
   */
  function checkTargetRef( art ) {
    if (art.kind === 'entity' || art.kind === 'aspect')
      return false;
    return art.kind !== 'type' || 'sloppy';
  }

  function checkSourceRef( art, path ) { // for FROM
    if (!art._main)
      return (art.kind !== 'entity');
    const elem = path.find( item => item._artifact._main )._artifact;
    // at least the last main definition should be an entity
    // an additional check for target would need effectiveType()
    return (elem && elem._main.kind !== 'entity');
  }

  // Return absolute name for unchecked path `ref`.  We first try searching for
  // the path root starting from `env`.  If it exists, return its absolute name
  // appended with the name of the rest of the path and set `ref.absolute` to
  // the return value.  Otherwise, complain if `unchecked` is false, and set
  // `ref.absolute` to the path name of `ref`.
  // Used for collecting artifact extension, and annotation assignments.
  //
  // Return '' if the ref is good, but points to an element.
  function resolveUncheckedPath( ref, refCtx, user ) {
    const { path } = ref;
    if (!path || path.broken) // incomplete type AST
      return undefined;

    const semantics = referenceSemantics[refCtx];
    let art = getPathRoot( ref, semantics, user );
    if (ref.scope && ref.scope !== 'global')
      return '';                // TYPE OF, Main:elem

    if (Array.isArray( art ))
      art = art[0];
    if (!art)
      return (semantics.notFound) ? art : pathName( path );
    if (path.length === 1)
      return art.name.absolute; // TODO: name.id
    return `${ art.name.absolute }.${ pathName( ref.path.slice(1) ) }`;
  }

  // Return artifact or element referred by the path in `ref`.  The first
  // environment we search in is `env`.  If no such artifact or element exist,
  // complain with message and return `undefined`.  Record a dependency from
  // `user` to the found artifact if `user` is provided.
  function resolvePath( ref, expected, user ) {
    const origUser = user;
    user = user._user || user;
    if (ref == null)       // no references -> nothing to do
      return undefined;
    if (ref._artifact !== undefined)
      return ref._artifact;

    const { path } = ref;
    if (!path || path.broken || !path.length) {
      // incomplete type AST or empty env (already reported)
      return setArtifactLink( ref, undefined );
    }

    const s = referenceSemantics[expected]; // TODO: temp indirection
    const semantics = (typeof s === 'string') ? referenceSemantics[s] : s;

    const r = getPathRoot( ref, semantics, origUser );
    const root = r && acceptPathRoot( r, ref, semantics, user );
    if (!root)
      return setArtifactLink( ref, root );

    let spec = specExpected[expected];
    if (ref.scope === 'param') {
      if (!spec.escape)
        throw new CompilerAssertion( 'getPathRoot() should have returned falsy val' );
      spec = specExpected[spec.escape];
    }

    // how many path items are for artifacts (rest: elements)
    // console.log(expected, ref.path.map(a=>a.id),artItemsCount)
    let art = getPathItem( ref, semantics, spec, user );
    if (!art)
      return setArtifactLink( ref, art );

    if (art.$autoElement) {
      const { location } = path[path.length - 1];
      const step = { id: art.$autoElement, $inferred: '$autoElement', location };
      art = art.elements[step.id];
      setArtifactLink( step, art );
      path.push( step );
    }
    if (spec.check && !ref.$expected) { // do not check with exists path (is already error)
      const fail = spec.check( art, path );
      if (fail === true) {
        signalNotFound( spec.expectedMsgId, [ ref.location, user ], null );
        return setArtifactLink( ref, false );
      }
      else if (fail) {
        signalNotFound( spec.sloppyMsgId, [ ref.location, user ], null );
        // no return!
      }
    }
    if (spec.warn) {
      const msgId = spec.warn( art, user );
      if (msgId)
        warning( msgId, [ ref.location, user ] );
    }
    if (user && (!spec.noDep ||
                 spec.noDep === 'only-entity' && art.kind !== 'entity')) {
      const { location } = ref; // || combinedLocation( head, path[tail.length] );
      // TODO: location of last path item if not main artifact
      if (spec.assoc === 'from' && art._main) {
        dependsOn( user, art._main, location );
        environment( art, location, user );
      }
      else if (art.kind !== 'select') { // no real dependency to bare $self
        dependsOn( user, art, location );
        // Without on-demand resolve, we can simply signal 'undefined "x"'
      // instead of 'illegal cycle' in the following case:
      //    element elem: type of elem.x;
      }
    }
    // TODO: follow FROM here, see csnRef - fromRef
    return setArtifactLink( ref, art );
  }

  /**
   * Resolve the type arguments of `artifact` according to the type `typeArtifact`.
   * User is used for semantic message location.
   *
   * For builtins, for each property name `<prop>` in `typeArtifact.parameters`, we move a value
   * in art.$typeArgs (a vector of numbers with locations) to `artifact.<prop>`.
   *
   * For non-builtins, we take either one or two arguments and interpret them
   * as `length` or `precision`/`scale`.
   *
   * Left-over arguments are errors for non-builtins and warnings for builtins.
   *
   * TODO: move to define.js (and probably rename), rewrite (consider syntax-unexpected-argument)
   *
   * @param {object}  artifact
   * @param {object} typeArtifact
   * @param {CSN.Artifact} user
   */
  function resolveTypeArgumentsUnchecked( artifact, typeArtifact, user ) {
    let args = artifact.$typeArgs || [];
    const parameters = typeArtifact?.parameters || [];

    if (parameters.length > 0) {
      // For Builtins
      for (let i = 0; i < parameters.length; ++i) {
        let par = parameters[i];
        if (!(par instanceof Object))
          par = { name: par };
        if (!artifact[par.name] && i < args.length)
          artifact[par.name] = args[i];
      }
      args = args.slice(parameters.length);
    }
    else if (args.length > 0 && !typeArtifact?.builtin) {
      // One or two arguments are interpreted as either length or precision/scale.
      // For builtins, we know what arguments are expected, and we do not need this mapping.
      // Also, we expect non-structured types.
      if (args.length === 1) {
        artifact.length = args[0];
        args = args.slice(1);
      }
      else if (args.length === 2) {
        artifact.precision = args[0];
        artifact.scale = args[1];
        args = args.slice(2);
      }
    }

    if (!artifact.$typeArgs)
      return;

    // Warn about left-over arguments.
    if (args.length > 0) {
      const loc = [ args[0].location, user ];
      if (typeArtifact?.builtin) {
        message( 'type-ignoring-argument', loc, { art: typeArtifact } );
      }
      else if (options.testMode) {
        // Ensure: parser reports error and sets $typeArgs to undefined if more than 2 parameter
        throw new CompilerAssertion( 'More than 2 type arguments set by parser' );
      }
    }
    artifact.$typeArgs = undefined;
  }

  function getPathRoot( { path, scope, location }, semantics, user ) {
    // TODO: use string value of isMainRef?
    const head = path[0];
    if (!head || !head.id)
      return undefined;         // parse error
    if (head._artifact !== undefined)
      return head._artifact;
    const ruser = user._user || user; // TODO: nicer name if we keep this

    // Handle expand/inline, `type of`, :param, global (internally for CDL):
    if (user._pathHead && !semantics.isMainRef) // in expand/inline
      semantics = semantics.nestedColumn();
    if (typeof scope === 'string') { // typeOf, param, global
      semantics = semantics?.[scope] && semantics[scope]( ruser, path, location );
      if (!semantics) {
        if (semantics == null)
          throw new CompilerAssertion( `Scope ${ scope } is not expected here` );
        return setArtifactLink( head, null );
      }
    }
    const valid = [];

    // Search in lexical environments, including $self/$projection:
    const { isMainRef } = semantics;
    const lexical = semantics.lexical?.( ruser ); // TODO: _pathHead?
    if (lexical) {
      const [ nextProp, dictProp ] = (isMainRef)
        ? [ '_block', 'artifacts' ]
        : [ '_$next', '$tableAliases' ];
      // let notApplicable = ...;  // for table aliases in JOIN-ON and UNION order-by
      for (let env = lexical; env; env = env[nextProp]) {
        const dict = env[dictProp] || Object.create(null);
        const r = dict[head.id];
        if (acceptLexical( r, path, semantics, user ))
          return setArtifactLink( head, r );
        valid.push( dict );
      }
    }

    // Search in $special (ex $self/$projection) and dynamic environment:
    const dynamicDict = semantics.dynamic( ruser, user._user && user._artifact );
    if (!dynamicDict)                // avoid consequential errors
      return setArtifactLink( head, null );
    const isVar = (semantics.dollar && head.id.charAt( 0 ) === '$');
    const dict = (isVar) ? model.$magicVariables.artifacts : dynamicDict;
    const r = dict[head.id];
    if (r)
      return setArtifactLink( head, r );

    if (!semantics.dollar)
      valid.push( dynamicDict );
    else
      valid.push( model.$magicVariables.artifacts, removeDollarNames( dynamicDict ) );
    if (semantics.notFound === false)
      return setArtifactLink( head, null );
    // TODO: streamline function arguments (probably: user, path, semantics )
    const undef = semantics.notFound( ruser, head, valid, dynamicDict,
                                      !isMainRef && user._user && user._artifact, path );
    return setArtifactLink( head, undef || null );
  }

  // Return artifact or element referred by path (array of ids) `tail`.  The
  // search environment (for the first path item) is `arg`.  For messages about
  // missing artifacts (as opposed to elements), provide the `head` (first
  // element item in the path)
  // TODO - think about setting _navigation for all $navElement – the
  // "ref: ['tabAlias']: inline: […]" handling might be easier
  // (no _pathHead consultation for key prop and renaming support)
  function getPathItem( ref, semantics, spec, user ) {
    // let art = (headArt && headArt.kind === '$tableAlias') ? headArt._origin : headArt;
    const { path } = ref;
    let artItemsCount = 0;
    const { isMainRef } = semantics;
    if (isMainRef) {
      artItemsCount = (typeof ref.scope === 'number' && ref.scope) ||
                      (ref.scope ? 1 : path.length);
    }
    let art = null;
    let nav = spec.assoc !== '$keys' && null; // false for '$keys'
    const last = path[path.length - 1];
    // TODO: change elementsEnv via semantics for static versus dynamic assoc navigation
    const elementsEnv = semantics.navigation || environment;
    for (const item of path) {
      --artItemsCount;
      if (!item?.id)    // incomplete AST due to parse error
        return undefined;
      if (item._artifact) { // should be there on first path element
        art = item._artifact;
        continue;
      }

      const prev = art;
      const envFn = (artItemsCount >= 0) ? artifactsEnv : elementsEnv;
      const env = envFn( art, item.location, user, spec.assoc );
      art = setArtifactLink( item, env?.[item.id] );

      if (!art) {
        // element was not found in environment

        // TODO (done?): if `env` was 0, we might set a dependency to induce an
        // illegal-cycle error instead of reporting via `errorNotFound`.
        if (prev.$uncheckedElements) { // magic variable / replacement variable
          signalNotFound( 'ref-unknown-var', [ item.location, user ], [ env ],
                          { id: pathName( path ) } );
        }
        else if (isMainRef && artItemsCount >= 0) { // artifact ref
          if (semantics.notFound === false)
            return null;
          // TODO: streamline funtion arguments (probably: user, path, semantics, prev )
          semantics.notFound( user, item, [ env ], null, prev, path );
        }
        else {
          errorNotFound( item, env, prev, spec, user );
        }
        return null;
      }
      // TODO: what what about extra dependencies if we navigate along
      // associations?  See also extra args for environment()
      nav = setSomeNavigationLinkForAssoc( nav, item, art, prev?.target, last, user );
      // need to do that here, because we also need to disallow Service.AutoExposed:elem
      if (isMainRef !== 'all' && artItemsCount === 0 &&
          art.$inferred === 'autoexposed' && !user.$inferred) {
        // Depending on the processing sequence, the following could be a
        // simple 'ref-undefined-art'/'ref-undefined-def' - TODO: which we
        // could "change" to this message at the end of compile():
        error( 'ref-unexpected-autoexposed', [ item.location, user ], { art },
               // eslint-disable-next-line max-len
               'An auto-exposed entity can\'t be referred to - expose entity $(ART) explicitly' );
        // return null;
      }
    }
    // Final checks on artifact (could be done in an extra function)
    if (art.$requireElementAccess) { // on some CDS variables
      // Path with only one item, but we expect an element, e.g. `$at.from`.
      signalMissingElementAccess(art, [ last.location, user ]);
    }
    return art;
  }

  // To be analysed what it does exactly, see changes #3660, #3666:
  function setSomeNavigationLinkForAssoc( nav, item, sub, target, last, user ) {
    if (nav) {              // we have already "pseudo-followed" a managed association
      // We currently rely on the check that targetElement references do
      // not (pseudo-) follow associations, otherwise potential redirection
      // there had to be considered, too.  Also, fk refs to sub elements in
      // combinations with redirections of the target which directly access
      // the potentially renamed sub elements would be really complex.
      // With our restriction, no renaming must be considered for item.id.
      setTargetReferenceKey( item.id );
    }
    // Now set an _navigation link for managed assocs in ON condition etc
    else if (target && nav != null) {
      // Find the original ref for sub and the original foreign key
      // definition.  This way, we do not need the foreign keys with
      // rewritten target element path, which might not be available at
      // this point (rewriteKeys in Resolver Phase 5).  If we want to
      // follow associations in foreign key definitions, rewriteKeys must
      // be moved to the on-demand Resolver Phase 2.
      let orig;             // for the original target element
      for (let o = sub; o; o = o.value && o.value._artifact) // TODO: or use _origin?
        orig = o;
      nav = (orig._effectiveType || orig).$keysNavigation;
      setTargetReferenceKey( orig.name.id );
    }
    return nav;

    function setTargetReferenceKey( id ) {
      const node = nav && nav[id];
      nav = null;
      if (node) {
        if (node._artifact) {
          // set the original(!) foreign key for the assoc - the "right" ones
          // after rewriteKeys() is the one with the same name.id
          setLink( item, '_navigation', node._artifact );
          if (item === last)
            return;
        }
        else if (item !== last) {
          nav = node.$keysNavigation;
          return;
        }
      }
      error( null, [ item.location, user ], {},
             // eslint-disable-next-line max-len
             'You can\'t follow associations other than to elements referred to in a managed association\'s key' );
    }
  }

  function errorNotFound( item, env, art, spec, user ) {
    if (art.name && art.name.select && art.name.select > 1) {
      // TODO: 'The current query has no element $(MEMBER)' with $self.MEMBER
      // and 'The sub query for alias $(ALIAS) has no element $(MEMBER)'
      // TODO: probably not extra messageId, but text variant
      // TODO: views elements are proxies to query-0 elements, not the same
      // TODO: better message text
      signalNotFound( 'query-undefined-element', [ item.location, user ],
                      [ env ], { id: item.id } );
    }
    else if (art.kind === '$parameters') {
      signalNotFound( 'ref-undefined-param', [ item.location, user ],
                      [ env ], { art: art._main, id: item.id } );
    }
    else {
      const variant = art.kind === 'aspect' && !art.name && 'aspect';
      signalNotFound( spec.undefinedDef || 'ref-undefined-element', [ item.location, user ],
                      [ env ], {
                        '#': variant,
                        art: (variant ? '' : searchName( art, item.id, 'element' )),
                        id: item.id,
                      } );
    }
    return null;
  }

  // Helper functions for resolve[Unchecked]Path, getPath{Root,Item}: -----------

  function acceptLexical( art, path, semantics, user ) {
    if (semantics.isMainRef || !art)
      return !!art;
    // Non-global lexical are table aliases, mixins and $self, $projection, $parameters,
    // Do not accept a lonely table alias and `$projection`
    // TODO: test table alias and mixin named `$projection`
    if (path.length === 1 && !user.expand && !user.inline) { // accept lonely…
      // allow mixins, and `up_` in anonymous target aspect:
      if (art.kind !== '$self' || path[0].id !== '$self')
        return art.kind === 'mixin' || art.kind === '$navElement';
      return true;
    }
    // return !art.$internal && art;
    return art.$inferred !== '$internal';
  }

  function acceptPathRoot( art, ref, semantics, user ) {
    const { path } = ref;
    const [ head ] = path;
    if (Array.isArray( art ))
      return getAmbiguousRefLink( art, head, user );
    switch (art.kind) {
      case 'using': {
        const def = model.definitions[art.name.absolute];
        if (!def)
          return def;
        if (def.$duplicates)
          return false;
        return setArtifactLink( head, def ); // we do not want to see the using
      }
      case 'mixin': {
        return setLink( head, '_navigation', art );
      }
      case '$navElement': {
        if (head.id === user.$extended)
          path.$prefix = user.$extended;
        setLink( head, '_navigation', art );
        return setArtifactLink( head, art._origin );
      }
      case '$self':             // TODO: remove $projection from CC
      case '$tableAlias': {
        setLink( head, '_navigation', art );
        setArtifactLink( head, art._origin ); // query source or leading query in FROM
        if (!art._origin)
          return art._origin;
        // if just table alias (with expand), mark `user` with `$noOrigin` to indicate
        // that the corresponding entity should not be put as $origin into the CSN.
        // TODO: remove again, should be easy enough in to-csn without.
        if (path.length === 1 && art.kind === '$tableAlias')
          user.$noOrigin = true;
        if (path.length === 1 && !semantics.allowBareSelf && !user.expand && !user.inline) {
          // TODO: better ref-invalid-self
          error( 'ref-unexpected-self', [ head.location, user ], { id: head.id } );
          // TODO: reject bare $projection here (new message id, configurable)
          // not really helpful to attach valid names here (would include $self)
        }
        return art;
      }
      case '$parameters': {     // TODO: remove from CC
        // TODO: if ref.scope='param' is handled, test that here, too ?
        const { id } = path[1];
        message( 'ref-obsolete-parameters', [ head.location, user ],
                 { code: `$parameters.${ id }`, newcode: `:${ id }` },
                 'Obsolete $(CODE) - replace by $(NEWCODE)' );
        // TODO: replace it in to-csn correspondingly, probably v5 or later in v4 ?
        return art;
      }
      default:
        return art;
    }
  }

  function getAmbiguousRefLink( arr, head, user ) {
    if (arr[0].kind !== '$navElement' || arr.some( e => e._parent.$duplicates ))
      return false;
    // only complain about ambiguous source elements if we do not have
    // duplicate table aliases, only mention non-ambiguous source elems
    const uniqueNames = arr.filter( e => !e.$duplicates);
    if (uniqueNames.length) {
      const names = uniqueNames.filter( e => e._parent.$inferred !== '$internal' )
        .map( e => `${ e.name.alias }.${ e.name.element }` );
      let variant = names.length === uniqueNames.length ? 'std' : 'few';
      if (names.length === 0)
        variant = 'none';
      error( 'ref-ambiguous', [ head.location, user ], { '#': variant, id: head.id, names });
    }
    return false;
  }

  // Functions for the secondary reference semantics ----------------------------

  function typeOfSemantics( user, [ head ] ) {
    // `type of` is only allowed for (sub) elements of main artifacts
    let struct = user;
    while (struct.kind === 'element')
      struct = struct._parent;
    if (struct === user._main && struct.kind !== 'annotation')
      return { dynamic: typeOfParentDict };
    error( 'type-unexpected-typeof', [ head.location, user ],
           { keyword: 'type of', '#': struct.kind } );
    return false;
  }

  function paramSemantics() {
    return { dynamic: artifactParams, notFound: undefinedParam };
  }
  function paramUnsupported( user, _path, location ) {
    error( 'ref-unexpected-scope', [ location, user ],
           // why an extra text for calculated elements? or separate for all?
           { '#': (user.$syntax === 'calc' ? 'calc' : 'std') } );
    return false;
  }

  // Functions for semantics.lexical: -------------------------------------------

  function userBlock( user ) {
    return definedViaCdl( user ) && user._block;
  }
  function justDollarSelf( user ) {
    const query = userQuery( user );
    if (!query)
      return user._main || user;
    // query.$tableAliases contains both aliases and $self/$projection
    const aliases = query.$tableAliases;
    const r = Object.create(null);
    if (aliases.$self.kind === '$self')
      r.$self = aliases.$self;
    // TODO: disallow $projection for ON conditions all together
    if (aliases.$projection?.kind === '$self')
      r.$projection = aliases.$projection;
    const { $parameters } = user._main.$tableAliases;
    if ($parameters)        // no need to test `kind`, just compiler-set “aliases”
      r.$parameters = $parameters;
    return { $tableAliases: r };
  }
  function tableAliasesAndSelf( user ) {
    return userQuery( user ) || user._main || user;
  }
  function tableAliasesIfNotExtendAndSelf( user ) {
    if (!user.$extended)
      return tableAliasesAndSelf( user );
    if (typeof user.$extended !== 'string') {
      const aliases = userQuery( user ).$tableAliases;
      user.$extended = Object.keys( aliases )[0];
    }
    return justDollarSelf( user );
  }

  // Functions called via semantics.dynamic: ------------------------------------

  function modelDefinitions() {
    return model.definitions;
  }
  function modelBuiltinsOrDefinitions( user ) {
    return definedViaCdl( user ) ? model.$builtins : model.definitions;
  }

  function artifactParams( user ) {
    const lexical = (user._main || user).$tableAliases;
    // TODO: already report error here if no parameters?
    return lexical?.$parameters?.elements || Object.create( null );
  }

  function typeOfParentDict( user ) {
    // CDL produces the following XSN representation for `type of elem`:
    //  { path: [{ id: 'type of'}, { id: 'elem'}], scope: 'typeOf' }
    return { 'type of': user._parent };
  }

  function targetElements( user, pathItemArtifact ) {
    // const assoc = user._parent;
    // const target = resolvePath( assoc.target, 'target', assoc );
    return environment( pathItemArtifact || user._parent, null, null, null, true );
  }

  function combinedSourcesOrParentElements( user ) {
    const query = userQuery( user );
    if (!query)
      return environment( user._main ? user._parent : user );
    return query._combined;     // TODO: do we need query._parent._combined ?
  }
  function parentElements( user ) {
    return environment( user._main && user.kind !== 'select' ? user._parent : user );
  }

  function queryElements( user ) {
    return environment( user );
  }

  function nestedElements( user ) {
    Functions.navigationEnv( user._pathHead ); // set _origin
    return environment( user._pathHead._origin );
  }

  function targetAspectOnly( prev ) {
    let env = Functions.navigationEnv( prev, null, null, 'targetAspectOnly' );
    while (env?.target && !env.targetAspect)
      env = env._origin || env.type?._artifact;
    if (env === 0)
      return 0;
    const target = env?.targetAspect;
    if (target) {
      if (target.elements)
        return target.elements;
      env = resolvePath( env.targetAspect, 'targetAspect', env );
    }
    return env?.elements || Object.create(null);
  }

  function artifactsEnv( art ) {
    return art._subArtifacts || Object.create(null);
  }

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.  View elements are calculated
  // on demand.
  // TODO: what about location/user when called from getPath ?
  // TODO: think of always acting as if falsyIfNone would be true
  //       (if not possible, move to second param position)
  function environment( art, location, user, assocSpec, falsyIfNone ) {
    const env = Functions.navigationEnv( art, location, user, assocSpec );
    if (env === 0)
      return 0;
    return env?.elements || !falsyIfNone && Object.create(null);
  }

  // Functions called via semantics.notFound: -----------------------------------

  function undefinedDefinition( user, item, valid, _dict, prev ) {
    // in a CSN source or for `using`, only one env was tested (valid.length 1) :
    const art = (!prev) ? item.id : searchName( prev, item.id, 'absolute' );
    signalNotFound( (valid.length > 1 ? 'ref-undefined-art' : 'ref-undefined-def'),
                    [ item.location, user ], valid, { art } );
    // TODO: improve text, use text variant for: "or builtin" or "definitions" or none
  }

  function undefinedForAnnotate( user, item, valid, _dict, prev ) {
    // in a CSN source, only one env was tested (valid.length 1):
    const art = (!prev) ? item.id : searchName( prev, item.id, 'absolute' );
    signalNotFound( (valid.length > 1 ? 'anno-undefined-art' : 'anno-undefined-def'),
                    // TODO: ext-undefined-xyz
                    [ item.location, user ], valid, { art } );
  }

  function undefinedParam( user, head, valid ) {
    // TODO: text variant if there are no parameters, or in artifactParameters()?
    signalNotFound( 'ref-undefined-param', [ head.location, user ], valid,
                    { art: user._main || user, id: head.id } );
  }

  function undefinedTargetElement( user, head, valid, _dict, pathItemArtifact ) {
    // is only called if there is a target, targetElements() returns falsy otherwise
    const { target } = pathItemArtifact?._effectiveType || user._parent;
    // TODO: better with $refs in filter conditions
    signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                    { '#': 'target', art: target, id: head.id } );
  }

  function undefinedVariable( user, head, valid ) {
    // TODO: avoid message if we have already complained about `(exists …)`?
    const { id } = head;
    const isVar = id.charAt( 0 ) === '$' && id !== '$self';
    signalNotFound( (isVar ? 'ref-undefined-var' : 'ref-expecting-const'),
                    [ head.location, user ],
                    valid, { '#': 'std', id } );
    // TODO: use s/th better than 'ref-expecting-const'?
  }

  function undefinedSourceElement( user, head, valid, dynamicDict ) {
    // TODO: we might mention both the "direct" and the "effective" type and
    // always just mentioned one identifier as not found
    const { id } = head;
    if (id.charAt( 0 ) === '$') {
      const tableAlias = dynamicDict[id]?._parent;
      // TODO: probably better to pass param `semantics` and calculate dynamic dict explicitly
      const alias = tableAlias?.kind === '$tableAlias' ? tableAlias.name?.alias : null;
      // TODO: mention $self without query
      signalNotFound( 'ref-undefined-var', [ head.location, user ], valid,
                      { '#': (alias ? 'alias' : 'std'), alias, id } );
    }
    else {
      const isVirtual = (user.name?.id === id && user.virtual?.val);
      const code = 'virtual null as ‹name›';
      signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                      { art: head.id, '#': isVirtual ? 'virtual' : 'std', code } );
    }
  }

  function undefinedParentElement( user, head, valid, dynamicDict ) {
    // TODO: we might mention both the "direct" and the "effective" type and
    // always just mentioned one identifier as not found
    const { id } = head;
    if (id.charAt( 0 ) === '$') {
      const queryOrMain = dynamicDict[id]?._parent;
      const withSelf = queryOrMain && (!queryOrMain._main || queryOrMain?.kind === 'select');
      signalNotFound( 'ref-undefined-var', [ head.location, user ], valid,
                      { '#': (withSelf ? 'self' : 'std'), alias: '$self', id } );
    }
    else {
      // TODO: extra msg like ref-rejected-on if elem found in source elements?
      // also whether users wronly tried to refer to aliases/mixins?
      const msgVar = userQuery( user ) ? 'query' : null;
      // TODO: better with ON in expand if that is supported
      signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                      { '#': msgVar, art: head.id } );
    }
  }

  function undefinedOrderByElement( user, head, valid, dynamicDict, _art, path ) {
    const { id } = head;
    const src = id.charAt( 0 ) !== '$' && user._combined?.[id];
    if (src && !Array.isArray(src)) {
      path.$prefix = src.name.alias; // pushing it to path directly could be problematic
      // configurable error:
      signalNotFound( 'ref-deprecated-orderby', [ head.location, user ], valid,
                      { id: head.id, newcode: `${ src.name.alias }.${ head.id }` } );
      return src;
    }
    undefinedParentElement( user, head, valid, dynamicDict );
    return null;
  }

  function undefinedNestedElement( user, head, valid ) {
    // environment( user._pathHead ); // set _origin
    const art = user._pathHead._origin;
    // if (!art) console.log('UNE:',user,user._pathHead)
    if (!art)
      return;                   // no consequential error
    // TODO: better message with $ref
    signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                    { art: searchName( art, head.id, 'element' ) } );
    // TODO: remove use of searchName() ?
  }

  // Low-level functions --------------------------------------------------------

  /**
   * Make a "not found" error and optionally attach valid names.
   *
   * @param {string} msgId
   * @param {any} location
   * @param {object[]} valid
   * @param  {object} [textParams]
   */
  function signalNotFound( msgId, location, valid, textParams ) {
    if (location.$notFound)
      return;
    location.$notFound = true;
    /** @type {object} */
    const err = message( msgId, location, textParams );
    if (valid) {
      const user = Array.isArray( location ) && location[1];
      err.validNames = (user && definedViaCdl( user )); // viaCdl -> '.'?
      valid.reverse();
      attachAndEmitValidNames( err, ...valid );
    }
  }

  /**
   * Emit a 'ref-expected-element' error for magic variable references
   * that require element accesses but don't do.
   * For example: `$at`, but `$at.from` or `$at.to` is required.
   *
   * @param {object} art
   * @param {any} location
   */
  function signalMissingElementAccess( art, location ) {
    const err = message( 'ref-expected-element', location,
                         { '#': 'magicVar', id: art.name.id } );
    // Mapping for better valid names: from -> $at.from
    const valid = Object.keys(art.elements || {}).reduce((prev, curr) => {
      prev[`${ art.name.id }.${ curr }`] = true;
      return prev;
    }, Object.create(null));
    attachAndEmitValidNames( err, valid );
  }

  /**
   * Attaches a dictionary of valid names to the given compiler message.
   * In test mode, an info message is emitted with a list of valid names.
   *
   * @param {CompileMessage} msg CDS Compiler message
   * @param  {...object} validDicts One ore more artifact dictionaries such as in `_block`.
   */
  function attachAndEmitValidNames( msg, ...validDicts ) {
    const viaCdl = msg.validNames; // TODO: move to argument list
    if (!options.testMode && !options.attachValidNames)
      return;

    const valid = Object.assign( Object.create( null ), ...validDicts );
    msg.validNames = Object.create( null );
    for (const name of Object.keys( valid )) {
      const art = valid[name];
      // ignore internal types such as cds.Association, ignore names with dot for
      // CDL references to main artifacts:
      if (!art.internal && !art.deprecated && art.$inferred !== '$internal' &&
          (viaCdl ? art._main || !name.includes('.') : art.kind !== 'namespace'))
        msg.validNames[name] = art;
    }

    if (options.testMode && !options.$recompile) {
      // no semantic location => either first of [loc, semantic loc] pair or just location.
      const loc = msg.$location[0] || msg.$location;
      const names = Object.keys(msg.validNames);
      names.sort();
      if (names.length > 22) {
        names.length = 20;
        names[20] = '…';
      }
      info( null, [ loc, null ],
            { '#': !names.length ? 'zero' : 'std' },
            { std: `Valid: ${ names.join(', ') }`, zero: 'No valid names' });
    }
  }
}

function removeDollarNames( dict ) {
  const r = Object.create( null );
  for (const name in dict) {
    if (name.charAt( 0 ) !== '$')
      r[name] = dict[name];
  }
  return r;
}

module.exports = {
  fns,
};

import { BigIntStats, Dirent, PathLike, StatOptions, Stats, WriteFileOptions } from 'fs';
import { TypedEmitter } from 'tiny-typed-emitter';
import * as LS from 'vscode-languageserver';
import { Range, _Connection, _Connection as IConnection } from 'vscode-languageserver';
import * as LSP from 'vscode-languageserver-protocol';

export declare const lspRoot: string;
export type Uri = string;
export type AbsolutePath = string;
export type WorkspaceRelativePath = string;
export type FileContent = string;
export type Kind = "context" | "service" | "namespace" | "entity" | "event" | "view" | "type" | "annotation" | "annotate" | "action" | "function" | "const" | "role" | "aspect" | "accesspolicy" | "mixin" | "element" | "query" | "param" | "enum" | "source" | "using" | "extend" | "qualifiedAnnotation";
export interface Thing {
	kind: XsnKind;
	name: XsnBaseName;
	location: XsnLocation;
	_artifact?: XsnArtifact;
	value?: XsnExtensionName;
	$duplicates?: boolean | Thing[];
}
export interface CdsvTextPosition {
	line: number;
	column: number;
}
export interface CdsvLocation {
	start: CdsvTextPosition;
	end: CdsvTextPosition;
	filename?: string;
}
export interface CdsvDefinitionName {
	absolute: string;
	id?: string;
	location?: CdsvLocation;
}
export interface WithLocation {
	location: XsnLocation;
}
export interface CdsvArtifact extends WithLocation {
	kind: CdsvKind;
	name: CdsvDefinitionName;
}
export interface CdsvDefinition extends CdsvArtifact {
	elements?: CdsvArtifact[];
	builtin?: boolean;
	internal?: boolean;
	expectedKind?: string;
	parameters?: string[];
	annotationAssignments?: any[];
	artifacts?: CdsvDefinitions;
	vocabularies?: CdsvDefinitions;
}
export type CsnSeverity = "Error" | "Warning" | "Info" | "Debug";
export interface XsnParseModel extends CdsvAstNode {
	dependencies?: Array<{
		location: XsnLocation;
		val: string;
	}>;
	options: CdsvParseOptions;
	tokens: unknown[];
	ruleTree: unknown;
	toolbox: IXsnToolbox;
}
export interface CdsvAstNodeName {
	id: string;
}
export interface CdsvAstNode {
	artifacts?: {
		[localName: string]: CdsvAstNode;
	};
	extensions?: CdsvAstNode[];
	elements?: CdsvAstNode[];
	name: CdsvAstNodeName;
	kind: CdsvKind;
	location: CdsvLocation;
	annotationAssignments?: XsnAnnotationAssignment[];
}
export interface CdsvDefinitions {
	[id: string]: CdsvDefinition;
}
export type CdsvKind = "context" | "entity" | "extend" | "element" | "namespace" | "using" | "service" | "source" | "type" | "view";
export interface CdsvParseOptions {
	parseOnly?: boolean;
	lintMode?: boolean;
	attachTokens?: boolean;
	ambigDetection?: boolean;
	fallbackParser?: string;
	messages: XsnMessage[];
	parseListener?: unknown;
}
export interface CdsvCompileOptions {
	fallbackParser?: "cds";
	attachValidNames?: boolean;
	attachTokens?: boolean;
	docComment?: boolean;
	messages?: XsnMessage[];
	parseListener?: unknown;
}
export interface ModuleOrigin {
	__loadedFrom: string;
	__logicalLocation: string;
}
export interface ICdsCompiler extends ModuleOrigin {
	parse(source: FileContent, filename: AbsolutePath, options?: CdsvParseOptions): XsnParseModel;
	compile(fileNames: AbsolutePath[], dir?: AbsolutePath, options?: CdsvCompileOptions, map?: CdsvSourceDictionary): Promise<XsnCompileModel>;
	version(): string;
	$lsp: ICdsCompiler;
	getArtifactName(thing: any): any;
	getSpecialFunctions?(): string[];
	createToolbox(): IXsnToolbox;
}
export interface CdsvSourceDictionary {
	[localPath: AbsolutePath]: FileContent;
}
export interface XsnArtifacts {
	[localName: string]: XsnArtifact;
}
export interface XsnElements {
	[localName: string]: XsnElement;
}
export interface XsnSources {
	[absoluteLocalPath: AbsolutePath]: XsnSource;
}
export type ResolutionStep = "ToDefinition" | "ToNextExplicitAlias";
export interface ResolutionOptions {
	step: ResolutionStep;
}
export interface IXsnToolbox {
	resolve(thing: any, options?: ResolutionOptions): any[];
	nameLocation(thing: any): XsnLocation | undefined;
	absoluteNameOf(thing: any): string | undefined;
	locationOf(thing: any): XsnLocation;
	originOf(thing: any): any;
	getKind(thing: Thing): Kind;
	expectedKindOf(thing: Thing): XsnKind;
	fullyQualifiedNameOf(thing: Thing): any;
	nameLocationOf(thing: any): XsnLocation | undefined;
	filterMessagesInScope(position: LSP.Position, message: XsnMessage, relativeProvokerPosition: number): boolean;
	queriesOf(t: any): XsnArtifact[];
	excludesOf(t: any): any;
	orderBys(t: any): any;
	sourcesOf(ast: XsnCompileModel): XsnSources;
	extract(model: XsnCompileModel, callback: IXsnExtraction): Error[];
	isImplicitNamespace(thing: any): boolean;
	isLocalizedInferred(artifact: any): boolean;
	isAutoexposed(thing: any): boolean;
	name(thing: any): XsnName;
	isReturnsCarrier(thing: any): boolean;
}
export interface XsnCompileModel {
	vocabularies?: XsnArtifacts;
	definitions: XsnArtifacts;
	sources: XsnSources;
	$sources: XsnSources;
	version: {
		creator: string;
		csn: string;
	};
	options: CdsvCompileOptions & {
		messages: XsnMessage[];
	};
	workspaceRoot: AbsolutePath;
	compilerVersion: string;
	compiler: ICdsCompiler;
	toolbox: IXsnToolbox;
}
export interface XsnMessage {
	home?: string;
	message: string;
	messageId?: string;
	expectedTokens?: string[];
	validNames?: {
		[id: string]: CdsvDefinition;
	};
	$location: XsnLocation;
	severity: CsnSeverity;
}
export interface XsnSource {
	vocabularies?: XsnArtifacts;
	kind: "source";
	filename: string;
	dirname: string;
	realname: string;
	artifacts: XsnArtifacts;
	dependencies: XsnFileDependency[];
	extensions: XsnExtension[];
	usings: XsnArtifactUsing[];
	tokens: unknown[];
	ruleTree?: unknown;
	options: CdsvCompileOptions;
	namespace?: XsnSourceNamespace;
}
export interface XsnSourceNamespace {
	path: Array<{
		id: string;
		location: XsnLocation;
	}>;
}
export type XsnKind = "__i18n" | "aspect" | "using" | "entity" | "view" | "annotation" | "annotate" | "context" | "type" | "element" | "extend" | "service" | "namespace" | "param" | "builtin" | "qualifiedAnnotation";
export type DollarInferred = "*" | "autoexposed" | "expand-element" | "include" | "localized" | "localized-entity" | "localized-texts" | "proxy" | "query";
export interface XsnArtifact {
	doc?: XsnDocComment;
	kind: XsnKind;
	annotationAssignments: XsnAnnotationAssignment[];
	extern?: {
		location: XsnLocation;
		path: XsnPathSegment[];
	};
	location: XsnLocation;
	name: XsnName;
	artifacts?: XsnArtifacts;
	$duplicates?: XsnArtifact[] | boolean;
	blocks?: Array<{
		kind: "block";
		annotationAssignments: XsnAnnotationAssignment[];
		artifacts: XsnArtifacts;
		location: XsnLocation;
		name: XsnName;
	}>;
	elements?: XsnElements;
	enum?: XsnElements;
	actions?: XsnElements;
	returns?: any;
	params?: XsnElements;
	includes?: XsnArtifact[];
	queries?: XsnArtifact[];
	$queries?: XsnArtifact[];
	extensions?: XsnExtension[];
	$inferred?: DollarInferred;
	localized?: any;
	builtin?: boolean;
	vocabularies?: XsnArtifacts;
}
export interface XsnAnnotationAssignment {
	kind?: "annotate";
	location: XsnLocation;
	name: XsnExtensionName;
	value?: XsnFileDependency;
	val?: string;
	path?: XsnPathSegment[];
	symbol?: {
		id: string;
		location: XsnLocation;
	};
}
export interface XsnFileDependency {
	literal: string;
	location: XsnLocation;
	realname?: string;
	val: string;
}
export type XsnExtension = XsnExtendExtension | XsnAnnotateExtension;
export interface XsnExtendExtension {
	kind: "extend";
	expectedKind?: "service" | "context" | "entity" | "type" | "aspect" | "element";
	annotationAssignments: XsnAnnotationAssignment[];
	elements: XsnElements;
	location: XsnLocation;
	name: XsnExtensionName;
	artifacts?: XsnArtifacts;
}
export interface XsnAnnotateExtension {
	kind: "annotate";
	annotationAssignments: XsnAnnotationAssignment[];
	actions?: XsnElements;
	elements?: XsnElements;
	location: XsnLocation;
	name: XsnExtensionName;
	artifacts?: XsnArtifacts;
}
export interface XsnDocComment {
	val: string;
	location: XsnLocation;
}
export interface XsnElement {
	doc?: XsnDocComment;
	kind: "element";
	elements?: XsnElements;
	annotationAssignments: XsnAnnotationAssignment[];
	indexNo: number;
	location: XsnLocation;
	name: XsnElementName;
	type: XsnExtensionElementType;
	target?: XsnExtensionElementType;
	returns?: XsnExtensionElementType;
	$inferred?: DollarInferred;
}
export interface XsnElementName {
	absolute: string;
	element: string;
	id: string;
	location: XsnLocation;
}
export interface XsnExtensionElementType {
	absolute: string;
	location: XsnLocation;
	path: XsnPathSegment[];
	scope: number;
	_artifact?: Thing;
}
export interface XsnArtifactUsing {
	kind: "using";
	fileDep?: XsnFileDependency;
	annotationAssignments: XsnAnnotationAssignment[];
	extern?: {
		location: XsnLocation;
		path: XsnPathSegment[];
	};
	location: XsnLocation;
	name: XsnName;
	usings?: XsnArtifactUsing[];
}
export interface XsnBaseName {
	absolute: string;
	id: string;
	$inferred?: DollarInferred;
	location: XsnLocation;
	path?: XsnPathSegment[];
}
export interface XsnExtensionName extends XsnBaseName {
	location: XsnLocation;
	path: XsnPathSegment[];
	_artifact?: Thing;
}
export interface XsnName extends XsnBaseName {
	absolute: string;
	calculated?: boolean;
	action?: string;
	param?: string;
	element?: string;
	id: string;
	$inferred?: DollarInferred;
	location: XsnLocation;
	path?: XsnPathSegment[];
	query?: number;
	_artifact?: Thing;
}
export interface XsnLocation {
	file: WorkspaceRelativePath;
	line: number;
	col: number;
	endLine: number;
	endCol: number;
	$weak?: boolean;
}
export interface XsnPathSegment {
	id: string;
	location: XsnLocation;
	_artifact?: Thing;
}
export interface IXsnExtraction {
	onTokensFound<IPpToken>(absoluteLocalPath: AbsolutePath, tokens: IPpToken[], compilerVersion: string): void;
	onMessagesFound(model: XsnCompileModel, relativePath: WorkspaceRelativePath, messages: XsnMessage[]): void;
	onDefinitionFound(event: IXsnDefinitionEvent): void;
	onReferenceFound(event: IXsnReferenceEvent): void;
	onReferencesDone(event: IXsnExtractionEvent): void;
	onDirectDependenciesFound(absoluteLocalPath: string, dependentAbsoluteLocalPaths: string[]): void;
}
export interface IXsnExtractionEvent {
	compiler: ICdsCompiler;
	consumed: boolean;
	toolbox: IXsnToolbox;
	model?: XsnCompileModel;
}
export interface IXsnDefinitionEvent extends IXsnExtractionEvent {
	thing: any;
	fullyQualifiedName: string;
}
export interface IXsnReferenceEvent extends IXsnExtractionEvent {
	thing: any;
	hint?: string;
}
export interface IAnnotationAssignmentToken extends IGenericToken {
	readonly carrier: IIdentifierToken;
	readonly carrierName: string;
	readonly carrierNameRange?: LSP.Range;
}
export interface IGenericToken extends LSP.Position {
	readonly uri: Uri;
	readonly tokenIndex: number;
	readonly text: string;
	readonly annotationValue?: string;
	readonly range: LSP.Range;
	readonly location: LSP.Location;
	compare(position: LSP.Position): number;
}
export interface IStringLiteralToken extends IGenericToken {
	translationId?: string;
	isUsingPath?: boolean;
}
export interface IGenericDefinition {
	readonly symbolName: string;
	readonly fullyQualifiedName: string;
	readonly kind: XsnKind;
	readonly absoluteName: string;
}
export interface IIdentifierToken extends IGenericToken {
	readonly definitions?: IGenericDefinition | IGenericDefinition[];
}
export interface IFileIndex {
	idTokens: IIdentifierToken[];
	directDependentUris: string[];
	readonly annotationAssignments: IterableIterator<IAnnotationAssignmentToken>;
}
export interface IExplicitDefinition extends IGenericDefinition, LSP.Position {
	location: LSP.Location;
	nameLocation: LSP.Location;
	line: number;
	character: number;
	docComment?: string;
	isExtend?: boolean;
}
export interface IBlitzIndex {
	readonly builtUris: readonly string[];
	getTransitiveDependencies(uri: string): Set<string>;
	forUri(uri: string, create?: undefined | "create" | "warnCreate"): IFileIndex;
	forUri(uri: string, create: "noCreate"): IFileIndex | undefined;
}
export interface IContribution {
	initialize?: (context: IContributionContext) => Promise<void>;
}
declare enum Setting {
	MarkMissingTranslations = "cds.compiler.markMissingI18nDefault",
	OmitRedundantTypesInSnippets = "cds.completion.annotations.omitRedundantTypesInSnippets"
}
export interface Translation {
	uri: string;
	line: number;
	character: number;
	id: string;
	text: string;
}
export interface ITranslationProvider {
	resolve(sourceUri: string, translationId: string): Translation | undefined;
}
export interface ISettingsProvider {
	get(setting: Setting): unknown;
}
export interface IContributionContext {
	trace: IContributionTracer;
	translation: ITranslationProvider;
	settings: ISettingsProvider;
}
export type ContributionTraceMessage = () => string;
export interface IContributionTracer {
	debug(m: ContributionTraceMessage): void;
	verbose(m: ContributionTraceMessage): void;
	info(m: ContributionTraceMessage): void;
	warn(m: ContributionTraceMessage): void;
	error(m: ContributionTraceMessage): void;
}
export interface IAnnotationContribution extends IContribution {
	fetchCompletions?: (params: CdsCompletionParams) => Promise<CdsCompletionItem[]>;
	fetchDiagnostics?: (params: CdsDiagnosticParams) => Promise<CdsDiagnostics>;
	fetchQuickfixes?: (params: LSP.CodeActionParams) => Promise<CdsQuickfix[]>;
	fetchHover?: (params: CdsHoverParams) => Promise<CdsHover | undefined>;
	fetchDefinition?: (params: CdsDefinitionParams) => Promise<LSP.Location | LSP.Location[] | undefined>;
	fetchReferences?: (params: CdsDefinitionParams) => Promise<LSP.Location[]>;
	fetchSemanticTokens?: (params: CdsSemanticTokensParams) => Promise<SemanticToken[]>;
	indexAnnotationIdentifiers?: (params: CdsIndexingParams) => Promise<CdsAnnotationIndex>;
	indexAndValidate?: (params: CdsIndexingParams) => Promise<CdsAnnotationIndexAndDiagnostics>;
}
export interface CdsIndexingParams {
	uris: Uri[];
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsAnnotationIndexEntry {
	absoluteName: string;
	definition: LSP.Location;
	references: LSP.Location[];
}
export type CdsDiagnostics = Map<Uri, LSP.Diagnostic[]>;
export type CdsAnnotationIndex = CdsAnnotationIndexEntry[];
export interface CdsAnnotationIndexAndDiagnostics {
	annotationIndex: CdsAnnotationIndex;
	diagnostics: CdsDiagnostics;
}
export type CdsQuickfix = Omit<LSP.CodeAction, "command">;
export interface CdsCompletionParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	index: IBlitzIndex;
	annotation: IAnnotationAssignmentToken;
	ast: XsnCompileModel;
	relativeLocalPath: string;
	isCompoundAnnotation: boolean;
}
export interface CdsDiagnosticParams {
	uris: Uri[];
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsHoverParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	annotation: IAnnotationAssignmentToken;
	index: IBlitzIndex;
}
export interface CdsDefinitionParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	annotation: IAnnotationAssignmentToken;
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsHover extends LSP.Hover {
	contents: CdsMarkupContent;
}
export interface CdsMarkupContent extends LSP.MarkupContent {
	kind: "markdown";
}
export interface CdsCompletionItem extends LSP.CompletionItem {
	data?: unknown;
}
export interface CdsSemanticTokensParams {
	uri: Uri;
	index: IBlitzIndex;
}
export interface SemanticToken {
	line: number;
	character: number;
	length: number;
	tokenType: LSP.SemanticTokenTypes;
	tokenModifiers: LSP.SemanticTokenModifiers[];
}
export interface TestServer {
	listen(connection: LS.Connection): void;
}
export interface TestAnnotationContribution {
	name: string;
	description: string;
	version: string;
	handler: IAnnotationContribution;
}
export declare function createCdsLanguageTestServer(contributions: TestAnnotationContribution[]): Promise<TestServer>;
export interface AntlrToken {
	tokenIndex: number;
	start: number;
	stop: number;
	type: any;
	isIdentifier?: string;
	line: number;
	column: number;
	text: string;
}
declare const RelevantGrammarRuleNames: readonly [
	"start",
	"actionFunctionDef",
	"actionFunctionMainDef",
	"annotateElement",
	"annotationAssignment_atn",
	"annotationAssignment_fix",
	"annotationAssignment_ll1",
	"annotationAssignment_1",
	"annotationAssignment_paren",
	"annotationDef",
	"annoValue",
	"annoSubValue",
	"artifactDefOrExtend",
	"cardinalityAndFilter",
	"condition",
	"conditionTerm",
	"contextDef",
	"elementDef",
	"elementDefInner",
	"elementDefOrExtend",
	"elementType",
	"entityDef",
	"expression",
	"extendArtifact",
	"extendContext",
	"extendProjection",
	"flattenedValue",
	"usingProxy",
	"mixinElementDef",
	"namedValue",
	"namespaceDeclaration",
	"orderBySpec",
	"parameterListDef",
	"projectionExclusion",
	"projectionSpec",
	"queryExpression",
	"queryTerm",
	"queryPrimary",
	"returnTypeSpec",
	"selectItemDef",
	"selectItemInlineList",
	"serviceDef",
	"tableExpression",
	"typeAssociationBase",
	"typeAssociationCont",
	"typeAssociationElementCont",
	"typeCompoStruct",
	"typeDef",
	"typeNamedArg",
	"typeNamedArgList",
	"typeRefArgs",
	"typeRefOptArgs",
	"typeSpecSemi",
	"typeStruct",
	"usingDeclaration",
	"viewDef"
];
export type BlockRule = typeof RelevantGrammarRuleNames[number];
export type TokenCategory = "Identifier" | "Keyword" | "Operator" | "String" | "number" | "Comment" | "LineComment" | "DocComment" | "<EOF>" | "<???>";
export type IdentifierCategory = "Namespace" | "Using" | "global" | "Context" | "Service" | "Type" | "Enum" | "Entity" | "Extend" | "Element" | "Action" | "BoundAction" | "Param" | "paramname" | "Event" | "AnnoDef" | "Annotate" | "anno" | "name" | "variant" | "artref" | "ref" | "FromAlias" | "Item" | "Mixin" | "Key" | "enumref";
export type RelativeToCursor = "tokenAfterCursor" | "tokenStartsAtCursor" | "tokenContainsCursor" | "tokenEndsWithCursor" | "tokenBeforeCursor";
export interface IToken extends LSP.Range, LSP.Position {
	readonly endOffset: number;
	readonly category: TokenCategory;
	line: number;
	character: number;
	text: string;
	readonly endLine: number;
	readonly endCharacter: number;
	readonly tokenIndex: number;
	readonly startTokenIndex: number;
	readonly end: LSP.Position;
	readonly start: LSP.Position;
	startOffset: number;
	originalText: string;
	ejected: boolean;
	readonly identifierCategory?: IdentifierCategory;
	id: string;
	isIdentifier(): boolean;
	isOperator(): boolean;
	isKeyword(): boolean;
	isComment(): boolean;
	isLineComment(): boolean;
	isBlockComment(): boolean;
	isDocComment(): any;
	relativeToCursor(cursor: LSP.Position): RelativeToCursor;
	getLowerLexem(): string;
	isSingleLined(): boolean;
	compare(position: LSP.Position): number;
}
export interface IRuleToken extends IToken {
	id: string;
	readonly isErrorToken: boolean;
	readonly context: ITokenContext;
	finalizeCategory(antlrToken: AntlrToken, category: TokenCategory): void;
	parent: IRuleNode;
	getNextToken(predicate?: (token: IRuleToken) => boolean): IRuleToken | undefined;
	getPreviousToken(predicate?: (token: IRuleToken) => boolean): IRuleToken | undefined;
	isCqlKeyword(): boolean;
	isInlineComment(): boolean;
	isSingleLined(): boolean;
	isFollowUpComment(): boolean;
	clone(changes: {
		text?: string;
		line?: number;
		character?: number;
		startOffset?: number;
	}): IRuleToken;
	getFollowUpLineEndComment(): any;
}
export interface IRuleNode {
	readonly id: string;
	readonly ruleName: BlockRule;
	parent?: IRuleNode;
	children: IRuleItem[];
	readonly startTokenIndex: number;
	readonly endTokenIndex: number;
	readonly containedTokens: IRuleToken[];
	readonly allTokens: IRuleToken[];
	readonly context: ITokenContext;
	readonly data: Record<string, unknown>;
	getFirstToken(predicate?: (token: IRuleToken) => boolean): IRuleToken | undefined;
	getLastToken(predicate?: (token: IRuleToken) => boolean): IRuleToken | undefined;
	toString(): string;
}
export type IRuleItem = IRuleNode | IRuleToken;
export interface ITokenContext {
	readonly ruleTokens: IRuleToken[];
	messages: XsnMessage[];
}
export type ArgumentsRenderer<This> = (args: any, thisArg: This, currentTraceLevel: LspTraceLevel) => string | unknown;
export type ResultRenderer<This, Return> = (res: Awaited<Return>, args: any, thisArg: This, currentTraceLevel: LspTraceLevel) => string | unknown;
export interface FootprintCustomizer<This, Return> {
	traceLevel?: LspTraceLevel;
	scope?: string;
	startScope?: string;
	endScope?: string;
	argumentsRenderer?: ArgumentsRenderer<This>;
	resultRenderer?: ResultRenderer<This, Return>;
	trackMemory?: boolean;
	onlyTraceStart?: boolean;
	onlyTraceEnd?: boolean;
}
export interface ITracer {
	isTracing(level: LspTraceLevel): boolean;
	debug(m: TraceMessage): void;
	verbose(m: TraceMessage): void;
	info(m: TraceMessage): void;
	warn(m: TraceMessage): void;
	error(m: TraceMessage): void;
	footprint<This, Return>(thisArg: This, action: Callback<Return>, args: any[], customizer: FootprintCustomizer<This, Return>): Return;
	conditionalTrace(_level: LspTraceLevel, _message: TraceMessage): void;
}
export type Callback<Return> = (...args: any[]) => Return;
declare enum LspTraceLevel {
	invalid = 0,
	OFF = 1,
	INFRASTRUCTURE = 2,
	ERROR = 3,
	WARNING = 4,
	INFO = 5,
	VERBOSE = 6,
	DEBUG = 7,
	IGNORE = 8
}
declare enum LspTraceComponent {
	ALL = "*",
	ADAPTER = "adapter",
	COMPLETION = "completion",
	COMPILER = "compiler",
	CONTRIBUTION = "contribution",
	DOCUMENTATION = "docs",
	FORMATTING = "format",
	MODEL = "model",
	MODEL_TODOS = "model-todos",
	REFACTOR = "refactor",
	REQUESTS = "requests",
	SETTINGS = "settings",
	UTIL = "util",
	WORKSPACE = "workspace",
	FILES = "files",
	ENV = "cdsenv",
	COMMAND = "command",
	CONTEXT_LOG = "context-log"
}
export type ConfigLevel = "off" | "error" | "warning" | "info" | "verbose" | "debug";
export interface TraceComponent {
	name: LspTraceComponent;
	level: ConfigLevel;
}
export interface ITraceConfiguration {
	name?: string;
	folder?: string;
	components?: TraceComponent[];
	logfileCount?: number;
	logfileSize?: number;
}
export interface ITrace {
	configure(config: ITraceConfiguration): void;
	tracer(component: LspTraceComponent): ITracer;
	conditionalTrace(component: LspTraceComponent, level: LspTraceLevel, message: TraceMessage): void;
	doTraceToFile(message: string): void;
	renderMessage(level: LspTraceLevel, component: LspTraceComponent, message: TraceMessage): string;
	noTraceDuring<T>(f: () => Promise<T>): Promise<T>;
	traceLevel(component: LspTraceComponent): LspTraceLevel;
}
export type TraceMessage = () => string;
export type TraceComponentName = "*" | "adapter" | "compiler" | "completion" | "format" | "model" | "requests" | "util" | "workspace" | "build" | "update" | "lsp";
export type TraceLevel = "off" | "error" | "warning" | "info" | "verbose" | "debug";
export type WorkspaceRelativeUri = string;
export interface IStatistics {
	modelFiles: number;
	tokenCount: number;
	identifiers: number;
	definitions: number;
	references: number;
	translations: number;
	messages: number;
	directDependencies: number;
}
declare const FILE_DOES_NOT_EXIST: unique symbol;
export type T_FILE_DOES_NOT_EXIST = typeof FILE_DOES_NOT_EXIST;
export interface IImplicitDefinition extends IGenericDefinition {
}
export interface IBuiltinDefinition extends IImplicitDefinition {
}
export interface IFreeAnnotationDefinition extends IImplicitDefinition {
}
export interface IImplicitNamespaceDefinition extends IImplicitDefinition {
	location: LSP.Location;
	nameLocation: LSP.Location;
}
export interface _IPositionIndex<Target> {
	addOccurrence(target: Target, position: LSP.Position): void;
}
export interface IRequests {
	createAndCache<T extends IRequest>(ctor: RequestConstructor<T>): T;
}
export interface CompilerEvents {
	internalCompilerError: (stack: string) => void;
	compilerChanged: (lastUsedCompiler: ICdsCompiler) => void;
	[x: string]: any;
}
export interface _ICompiler extends TypedEmitter<CompilerEvents> {
	compile(localPath: AbsolutePath, workspaceRoot: AbsolutePath, files: CdsvSourceDictionary, options?: CdsvCompileOptions, cacheHandler?: ICacheHandler): Promise<XsnCompileModel>;
	parse(content: FileContent, localPath: AbsolutePath, dataTemplate?: Record<string, unknown>): {
		rootNode: IRuleNode;
		parseAst: XsnParseModel;
	};
	invalidateCacheMisses(): void;
}
export interface ICacheHandler {
	onNewCacheEntry(filePath: AbsolutePath, content: FileContent): boolean;
}
export interface _IDependencyNet {
	transitiveDependenciesFor(uri: Uri): ReadonlySet<Uri>;
	onFileChanged(uri: Uri, content: FileContent | T_FILE_DOES_NOT_EXIST): ReadonlySet<Uri>;
	allPotentialUsers(uri: Uri): Generator<Uri>;
	initFiles(files: Iterable<_IWorkspaceFileVersion>): void;
}
export interface _IPlatformTester {
	isWindows(): boolean;
}
export interface Cds extends ModuleOrigin {
	env: {
		for: (context: string, cwd: AbsolutePath, _defaults?: boolean) => Env;
	};
	home: AbsolutePath;
	resolve(modelFile: AbsolutePath, options: any): AbsolutePath[];
}
export interface _IPathResolver {
	resolveId(id: string, rootFolder: AbsolutePath): AbsolutePath | undefined;
}
export interface _IModuleLoader {
	_resolvedGlobalSapCdsHome?: AbsolutePath;
	resolver: _IPathResolver;
	loadBuiltInCompiler(): ICdsCompiler;
	loadCompiler(projectRoot: AbsolutePath): ICdsCompiler | never;
	loadCds(projectRoot: AbsolutePath): Cds;
	getProjectCdsHome(projectRoot: AbsolutePath): string | undefined;
	getGlobalCdsHome(): any;
}
export interface _IPathAdapter {
	readonly clientRootUri: Uri;
	readonly localRootPath: string;
	toUri(absolutePath: AbsolutePath): Uri;
	toLocalPath(uri: Uri): AbsolutePath;
	ensureAbsolutePath(localPath: WorkspaceRelativePath | AbsolutePath): AbsolutePath;
}
export interface _IEmergencyHooks {
	install(): void;
}
export interface ITelemetryData {
	type: "contributions ready" | "health" | "initialization completed" | "internal compiler error";
	[x: string]: any;
}
export interface _ITelemetry {
	addTelemetry(data: ITelemetryData): void;
}
export interface IInternalAnnotationContribution extends IAnnotationContribution {
	name: string;
	version: string;
}
export interface _IContributionLoader {
	loadAnnotationHandlers(afterInstallation: () => void): IInternalAnnotationContribution[] | undefined;
}
export interface _IWorkspaceDiagnostics {
	calculateAnnotationDiagnostics(index: IBlitzIndex, uris: Uri[], ast: XsnCompileModel): Promise<Map<Uri, LSP.Diagnostic[]>>;
	cleanDiagnostics(_workspaceFolderName: string): any;
	calculateCombinedDiagnosticsAndSend(uri: Uri, fileIndex: _IFileIndex, workspaceVersion: number): Promise<LSP.PublishDiagnosticsParams | null>;
}
declare const extendedLayers: readonly [
	"/",
	"db",
	"srv",
	"app"
];
export interface Env {
	folders: {
		[kind in typeof extendedLayers[number]]?: WorkspaceRelativePath;
	};
	i18n: I18n;
	cdsc: unknown;
	rootModels: {
		[kind in typeof extendedLayers[number]]?: WorkspaceRelativeUri[];
	};
}
export interface I18n {
	file: string;
	folders: string[];
	default_language: string;
	fallback_bundle: string;
}
declare enum ClientCapability {
	CLIENT_INFO_NAME = "clientInfo.name",
	CLIENT_INFO_VERSION = "clientInfo.version",
	CLIENT_NAME = "clientName",
	ACTIVE_EDITOR_CHANGED = "capabilities.workspace.cds.didChangeActiveEditor",
	CHANGE_CONFIG = "capabilities.workspace.didChangeConfiguration",
	CHANGE_WATCHED_FILES_REGISTRATION = "capabilities.workspace.didChangeWatchedFiles.dynamicRegistration",
	CODE_LENS = "capabilities.textDocument.codeLens",
	CONFIGURATION = "capabilities.workspace.configuration",
	SUPPORT_PROGRESS = "capabilities.window.workDoneProgress",
	SEMANTIC_TOKENS = "capabilities.textDocument.semanticTokens",
	SUPPORT_SNIPPETS = "capabilities.textDocument.completion.completionItem.snippetSupport",
	SUPPORTED_DOC_FORMATS = "capabilities.textDocument.completion.completionItem.documentationFormat",
	STATUS_MESSAGE = "capabilities.window.cds.statusMessage",
	USER_OUTPUT = "capabilities.window.cds.userOutput",
	WORKSPACEEDIT_DOCUMENTCHANGES = "capabilities.workspace.workspaceEdit.documentChanges"
}
declare enum UserSetting {
	CDS_TYPER_OUTPUT_PATH = "cds.typeGenerator.outputPath",
	CDS_TYPER_ENABLED = "cds.typeGenerator.enabled",
	CDS_TYPER_LOCAL_INSTALLATION_ONLY = "cds.typeGenerator.localInstallationOnly",
	DIAGNOSTICS_LEVEL = "cds.diagnosticsSeverity",
	WARN_MISSING_TRANSLATIONS = "cds.compiler.markMissingI18nDefault",
	SHOW_COMPILER_ERRORS = "cds.compiler.showInternalErrors",
	DOCS_IN_COMPLETION = "cds.completion.showDocumentation",
	DOCFILES_FOR_COMPLETION = "cds.completion.docFiles",
	FORMAT_SNIPPETS = "cds.completion.formatSnippets",
	DOCSYMBOLS_SEMANTICAL = "cds.outline.semantical",
	WORKSPACESYMBOLS_FOR_COMPLETION_MIN_PREFIX = "cds.completion.workspaceSymbols.minPrefixLength",
	WORKSPACESYMBOLS_FOR_COMPLETION_MAX_PROPOSALS = "cds.completion.workspaceSymbols.maxProposals",
	OMIT_REDUNDANT_TYPES_IN_SNIPPETS = "cds.completion.annotations.omitRedundantTypesInSnippets",
	CONTRIBUTIONS_REGISTRY = "cds.contributions.registry",
	CONTRIBUTIONS_ODATA_ENABLED = "cds.contributions.enablement.odata",
	CONTRIBUTIONS_LONGRUN_DETECT = "cds.contributions.enablement.longRunning.detect",
	CONTRIBUTIONS_LONGRUN_MAXMILLIS = "cds.contributions.enablement.longRunning.maxMillis",
	CONTRIBUTIONS_LONGRUN_REPEATS = "cds.contributions.enablement.longRunning.repeats",
	CONTRIBUTIONS_LONGRUN_TIMEFRAME = "cds.contributions.enablement.longRunning.timeFrameSeconds",
	IMPORT_ARTIFACT_QUICKFIX = "cds.quickfix.importArtifact",
	CODE_LENS_STATISTICS = "cds.codeLensStatistics.enabled",
	SEMANTIC_HIGHLIGHTING = "cds.semanticHighlighting.enabled",
	TRACE_COMPONENTS = "cds.trace.components",
	TRACE_LOGFILES_COUNT = "cds.trace.logfiles.count",
	TRACE_LOGFILES_MAXSIZE = "cds.trace.logfiles.maxSize",
	SHOW_GENERIC_ANNOTATIONS = "cds.whereused.showGenericAnnotations",
	SHOW_STRING_LITERALS = "cds.whereused.showStringConstants",
	WORKSPACE_DEBOUNCE_FAST_CHANGES = "cds.workspace.debounceFastChanges",
	WORKSPACE_SCAN_CSN = "cds.workspace.scanCsn",
	WORKSPACE_SCAN_DEPENDENT_MODULES = "cds.workspace.scanDependentModules",
	WORKSPACE_VALIDATION_MODE = "cds.workspaceValidationMode",
	WORKSPACESYMBOLS_LAZY = "cds.workspaceSymbols.lazy",
	WORKSPACESYMBOLS_CASE_INSENSITIVE = "cds.workspaceSymbols.caseInsensitive"
}
export interface ILspOptions {
	clientCapabilities: LSP.InitializeParams;
	userSettings: CdsDidChangeConfigurationParams;
	getClientCapability(name: ClientCapability | string, defaultValue?: any): any;
	getUserSetting<T>(name: UserSetting | string): T;
	setUserSettingTemporarily(name: UserSetting, value: any): void;
}
export interface _IWorkspaceStateContext {
	readonly adapter: _IPathAdapter;
	readonly options: ILspOptions;
	getCdsEnv(): Env;
	beforeRescan(): void;
	dependencyLevel(uri: Uri): number;
}
export interface WorkspaceDocumentsWithPossibleDeletions {
	[uri: Uri]: FileContent | T_FILE_DOES_NOT_EXIST;
}
declare enum WorkspaceValidationMode {
	ActiveEditorOnly = "ActiveEditorOnly",
	OpenEditorsOnly = "OpenEditorsOnly",
	OpenEditorsAndDirectSources = "OpenEditorsAndDirectSources",
	OpenEditorsDirectSourcesAndDirectDependencies = "OpenEditorsDirectSourcesAndDirectDependencies"
}
export interface IIndexContext {
	singleFile?: boolean;
	considerOnlyOpenFiles?: boolean;
	considerOnlyActiveFile?: boolean;
	onlyDefinitions?: boolean;
	debounce?: boolean;
	uri?: Uri;
}
export interface _IWorkspaceSnapshot {
	activeEditor?: Uri;
	workspaceVersion: number;
	dependencyNet: _IDependencyNet;
	files: WorkspaceFiles;
	readonly context: _IWorkspaceStateContext;
	streamFiles<T>(predicate?: (file: _IWorkspaceFileVersion) => boolean, mode?: WorkspaceValidationMode, mapper?: (file: _IWorkspaceFileVersion) => T): Generator<T>;
	getContent(uri: Uri): FileContent | T_FILE_DOES_NOT_EXIST;
	change(changedDiskDocs?: WorkspaceDocumentsWithPossibleDeletions, changedOpenDocs?: WorkspaceDocumentsWithPossibleDeletions, clone?: boolean): _IWorkspaceSnapshot;
	adapter: _IPathAdapter;
	reset(): _IWorkspaceSnapshot;
	isIndexDirty(uri: Uri, context: IIndexContext): boolean;
	findDirtyUris(context: IIndexContext): Uri[];
	sortByRank(uris: Uri[]): Uri[];
	fileIndexFor(uri: Uri): _IFileIndex | undefined;
	ensureScanned(env: Env): Promise<void>;
	isIgnored(_uri: Uri): boolean;
	isScanned(): boolean;
}
export type WorkspaceFolderKind = "normal" | "untitled" | "outsider";
export type IWorkspaceUpdated = {
	formerSnapshot: _IWorkspaceSnapshot;
	updatedSnapshot: _IWorkspaceSnapshot;
};
export type TranslationMap = Map<string, Translation>;
declare const annotationNamesForDocumentation: readonly [
	"title",
	"description"
];
export type AnnotationNamesForDocumentation = typeof annotationNamesForDocumentation[number];
export type Domain = AnnotationNamesForDocumentation | "translation" | "annotation domain" | "documentation";
export interface _IDocumentation {
	domain: Domain;
	content: CdsMarkupContent;
	source?: string;
}
export interface _ITranslationBroker {
	getTranslation(sourceUri: Uri, translationId: string): Translation | undefined;
	getAllTranslations(sourceFileUri: Uri): Translation[];
	onTranslationFileChanged(translationFileUri: Uri, content: FileContent | T_FILE_DOES_NOT_EXIST): void;
	getMostRelevantTranslationFileUri(forSourceUri: Uri): Uri | undefined;
	getTranslationIndex(translationFileUri: Uri): _II18nIndex;
	resetTranslations(): void;
}
export type TranslationType = "XTIT" | "XTOL" | "XMSG";
export interface _II18nIndex {
	map: TranslationMap;
	content: FileContent;
	readonly uri: Uri;
	readonly entries: IterableIterator<Translation>;
	index(cdsEnv: Env, content: FileContent): void;
	getEntry(tId: string): Translation | undefined;
	createEntry(cdsEnv: Env, tID: string, translationType: TranslationType, text: string): LSP.TextEdit[];
}
declare const ADD_TEXT_HERE = "<add text here>";
export type AddTextHere = typeof ADD_TEXT_HERE;
export interface INpmPackageMeta {
	readonly packageJsonFolderPath: AbsolutePath;
	readonly name: string;
	readonly version: string;
	readonly dependencies: {
		readonly [name: string]: AbsolutePath;
	};
	readonly devDependencies: {
		readonly [name: string]: AbsolutePath;
	};
}
export interface INpmPackages {
	getPackageRootFolder(filePath: AbsolutePath): INpmPackageMeta;
}
export interface _IWorkspaceFolder {
	readonly kind: WorkspaceFolderKind;
	adapter: _IPathAdapter;
	name: string;
	workspaceUri: string;
	workspaceRoot: string;
	translationBroker: _ITranslationBroker;
	documentationProvider: _IDocumentationProvider;
	readonly npmPackages: INpmPackages;
	workspaceSnapshot: _IWorkspaceSnapshot;
	lastRequestIndependentWorkspaceSnapshot: _IWorkspaceSnapshot;
	diagnostics: _IWorkspaceDiagnostics;
	triggerRevalidation(urisChanged?: Uri[]): Promise<{
		[uri: Uri]: LSP.Diagnostic[];
	}>;
	getCdsEnv(): Env;
	fetchTransitiveIndex(uri: Uri, context?: IIndexContext): Promise<IBlitzIndex>;
	fetchFileIndex(uri: Uri, context?: IIndexContext): Promise<_IFileIndex>;
	fetchToken(uri: Uri, position: LSP.Position, fetchAnnotationToken?: false | undefined): Promise<IIdentifierToken | IStringLiteralToken>;
	fetchToken(uri: Uri, position: LSP.Position, fetchAnnotationToken: true): Promise<IAnnotationAssignmentToken>;
	fetchAst(uri: Uri, snapshot?: _IWorkspaceSnapshot): Promise<XsnCompileModel>;
	getContent(uri: Uri): FileContent | T_FILE_DOES_NOT_EXIST;
	ensureScanned(): Promise<void>;
	progressSnapshot(changedDiskDocuments?: WorkspaceDocumentsWithPossibleDeletions, changedOpenDocuments?: WorkspaceDocumentsWithPossibleDeletions, updateCurrentRequestSnapshot?: boolean): IWorkspaceUpdated;
	readContent(uri: Uri): FileContent | T_FILE_DOES_NOT_EXIST;
}
export interface _IUsingPathResolver {
	resolveUsingPath(triggerUri: Uri, importPath: string, workspaceFolder: _IWorkspaceFolder): Uri | undefined;
}
export interface WorkspaceServiceEvents {
	onWorkspaceFolderAdded: (workspaceFolder: _IWorkspaceFolder) => void;
}
export interface _IWorkspaceService extends TypedEmitter<WorkspaceServiceEvents> {
	getWorkspaceFolder(uri: Uri): _IWorkspaceFolder;
	workspaceFolders(filter?: (wsf: _IWorkspaceFolder) => boolean): _IWorkspaceFolder[];
	getWorkspaceSettingsPath(): AbsolutePath | undefined;
	addWorkspaceFolder(workspaceFolderConfig: LSP.WorkspaceFolder): _IWorkspaceFolder | undefined;
	removeWorkspaceFolder(rootUri: Uri): void;
}
declare enum QuickFixCommands {
	IMPORT_ARTIFACT = "import-artifact",
	MAINTAIN_TRANSLATION = "maintain-translation",
	MIGRATE_TO_DOCCOMMENT = "migrate-to-doccomment",
	MIGRATE_DEPRECATED_DELIMITER = "migrate-deprecated-delimiter",
	CUSTOM_ANNOTATION_QUICKFIX = "custom-annotation-quickfix"
}
export interface IQuickFixHandler {
	readonly id: QuickFixCommands;
	calculateDiagnostics(uri: string, index: IFileIndex): LSP.Diagnostic[];
	createCodeActions(params: LSP.CodeActionParams): Promise<LSP.CodeAction[]>;
	execute(params: LSP.ExecuteCommandParams): Promise<any>;
}
declare const CommandNames: readonly [
	"format-range",
	"analyze-dependencies",
	"active-editor-changed",
	"parse-tree"
];
export type CommandName = typeof CommandNames[number];
export interface ICommandHandler {
	execute(params: LSP.ExecuteCommandParams): Promise<unknown>;
}
export interface ICdsExecuteCommandParams extends LSP.ExecuteCommandParams {
	command: CommandName | QuickFixCommands;
}
export interface IAnalyzeDependenciesParams extends ICdsExecuteCommandParams {
	command: "analyze-dependencies";
	arguments: [
		IAnalyzeDependenciesArguments
	];
}
export interface IAnalyzeDependenciesArguments {
	startModelUri: Uri;
	outputUri: Uri;
	detailMode?: DetailMode;
}
export type DetailMode = "file2file" | "file2folder" | "folder2folder";
export interface IActiveEditorChangedParams extends ICdsExecuteCommandParams {
	command: "active-editor-changed";
	arguments: [
		IActiveEditorChangedArguments
	];
}
export interface IActiveEditorChangedArguments {
	previousActiveUri: Uri;
	newActiveUri: Uri;
}
export interface DiagnosticsState {
	uri: string;
	workspaceVersion: number;
	diagnostics: LSP.Diagnostic[];
	diagnosticsHash?: string;
}
export interface IClientProblems {
	updateFile(uri: Uri, newState: DiagnosticsState | null, currentWorkspaceVersion?: number): LSP.PublishDiagnosticsParams | null;
	cleanDiagnostics(): {
		[p: Uri]: LSP.Diagnostic[];
	};
}
export interface _ILanguageServer {
	fetchAnnotationHandlers(): Promise<IInternalAnnotationContribution[]>;
	prettyPrinter: unknown;
	trace: ITrace;
	telemetry: _ITelemetry;
	platformTester: _IPlatformTester;
	connection?: LS.Connection;
	requests: IRequests;
	sendDiagnostics(params: LSP.PublishDiagnosticsParams): Promise<void>;
	userInterface: IUserInterface;
	applyWorkspaceEdits(params: LSP.ApplyWorkspaceEditParams): Promise<any>;
	workspaceService: _IWorkspaceService;
	usingPathResolver: _IUsingPathResolver;
	moduleLoader: _IModuleLoader;
	options: ILspOptions;
	quickFixes: Map<QuickFixCommands, IQuickFixHandler>;
	commands: Map<CommandName, ICommandHandler>;
	compiler: _ICompiler;
	fileSystem: _IFileSystem;
	clientProblems: IClientProblems;
	request<T extends IRequest>(t: RequestConstructor<T>): T;
}
export declare const UserOutputNotification = "cds/userOutput";
export interface IUserOutputNotification {
	message: string;
	reveaOutputWindowlIfHidden: boolean;
}
export declare const StatusMessageNotification = "cds/statusMessage";
export interface IStatusMessageNotification {
	message: string;
	millisToShow: number;
}
export type PopupType = "Information" | "Warning" | "Error";
export interface IUserInterface {
	userOutput(message: string, revealOutputWindowIfHidden?: boolean): void;
	statusMessage(message: string, millisToShow?: number): void;
	userNotification(message: string, type?: LSP.MessageType): void;
	userPopup(type: PopupType, message: string, ...buttons: string[]): Promise<string>;
}
export interface _ILanguageServerEx extends _ILanguageServer {
	registerRequestHandlers(connection: LS._Connection): void;
}
export type RequestConstructor<T extends IRequest> = new (ls: _ILanguageServer) => T;
export interface IRequest {
	readonly languageServer: _ILanguageServer;
}
export interface _IDocumentationProvider {
	fetchTokenDocumentation(genericToken: IGenericToken): IterableIterator<_IDocumentation>;
	streamDefinitionDocumentations(sourceUri: Uri, definitions: IGenericDefinition[]): IterableIterator<_IDocumentation>;
}
export interface _IWorkspaceFileVersion {
	content: FileContent;
	fileIndex?: _IFileIndex;
	readonly uri: Uri;
	isOpen: boolean;
	readonly isOutsider: boolean;
	progress(newContent: FileContent, isOpen: boolean): _IWorkspaceFileVersion;
}
export type WorkspaceFiles = Map<Uri, _IWorkspaceFileVersion>;
export interface IAnnotationHandlerProvider {
	getAnnotationHandlers(): IInternalAnnotationContribution[];
}
export interface ImplicitDefinitions {
	builtIns: {
		[absoluteName: string]: IBuiltinDefinition;
	};
	implicitNamespaces: {
		[absoluteName: string]: IImplicitNamespaceDefinition;
	};
	freeAnnotations: {
		[absoluteName: string]: IFreeAnnotationDefinition;
	};
}
export interface IFactory {
	createAnnotationHandlerProvider(languageServer: _ILanguageServer): IAnnotationHandlerProvider;
	createOptions(): ILspOptions;
	getTrace(): ITrace;
	getEmergencyHooks(): _IEmergencyHooks;
	getPlatformTester(): _IPlatformTester;
	getModuleLoader(resolvedGlobalSapCdsHome?: AbsolutePath): _IModuleLoader;
	createPathAdapter(clientRootUri: Uri, localRootPath?: AbsolutePath): _IPathAdapter;
	createServer(): _ILanguageServerEx;
	createService(languageServer: _ILanguageServer): _IWorkspaceService;
	createWorkspace(kind: "outsider" | "untitled", languageServer: _ILanguageServer): _IWorkspaceFolder;
	createWorkspace(kind: "normal" | WorkspaceFolderKind, languageServer: _ILanguageServer, name: string, adapter: _IPathAdapter): _IWorkspaceFolder;
	createSnapshot(context: _IWorkspaceStateContext, scanning: boolean): _IWorkspaceSnapshot;
	createFile(uri: Uri, content: FileContent, isOpen?: boolean): _IWorkspaceFileVersion;
	createCompiler(options: ILspOptions, loader: _IModuleLoader): _ICompiler;
	createTelemetry(connection: _Connection): _ITelemetry;
	getContributionLoader(): _IContributionLoader;
	createDependencyNet(workspaceRoot: AbsolutePath): _IDependencyNet;
	createFileIndex(uri: Uri, workspaceVersion: number, _implicitDefinitions: ImplicitDefinitions): _IFileIndex;
	getFileSystem(): _IFileSystem;
	createToolbox(compiler: ICdsCompiler): IXsnToolbox;
}
declare enum LspFileType {
	Unrelated = "Unrelated",
	PackageJson = "PackageJson",
	IgnoreFile = "IgnoreFile",
	TranslationDefinitions = "TranslationDefinitions",
	CdsSource = "CdsSource",
	CsnFile = "CsnFile",
	CdsEnv = ".cdsrc.json"
}
export interface _IFileSystem {
	isTranslationFile(cdsEnv: Env, uriOrFilepath: Uri | AbsolutePath): boolean;
	isPackageJsonFile(uriOrFilepath: Uri | AbsolutePath): boolean;
	typeofFile(uri: Uri, cdsEnv: Env, getContent: () => FileContent | T_FILE_DOES_NOT_EXIST): LspFileType;
	isCsnFileByExtension(uriOrFilepath: Uri | AbsolutePath): boolean;
	isCsnFile(uriOrFilepath: Uri | AbsolutePath, getContent: () => FileContent | T_FILE_DOES_NOT_EXIST): boolean;
	isCdsEnvFile(uri: Uri): boolean;
	isIgnoreFile(uriOrFilepath: Uri | AbsolutePath): boolean;
	isCdsSourceFile(uriOrFilepath: Uri | AbsolutePath): boolean;
	isCdsFile(uriOrFilepath: Uri | AbsolutePath, content?: FileContent | T_FILE_DOES_NOT_EXIST): boolean;
	isFileSystemRoot(abs: AbsolutePath): boolean;
	existsSync(p: AbsolutePath): boolean;
	readFile(path: AbsolutePath): Promise<FileContent>;
	readFileSync(path: AbsolutePath): FileContent;
	writeFileSync(path: PathLike, data: FileContent | NodeJS.ArrayBufferView, options?: WriteFileOptions): void;
	copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;
	unlinkSync(p: PathLike): void;
	mkdir(p: PathLike): Promise<AbsolutePath | undefined>;
	mkdirSync(p: PathLike): void;
	mkdtempSync(prefix: string): AbsolutePath;
	rmdir(p: PathLike): Promise<void>;
	rmdirSync(p: PathLike): void;
	readdirSync(path: PathLike, withFileTypes?: false | undefined): string[];
	readdirSync(path: PathLike, withFileTypes: true): Dirent[];
	statSync(p: PathLike): Stats;
	realpathSync(p: PathLike): AbsolutePath;
	realpathSyncNative(p: PathLike): AbsolutePath;
	stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
	stat(path: PathLike, options: StatOptions & {
		bigint?: false | undefined;
	} | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
	stat(path: PathLike, options: StatOptions & {
		bigint: true;
	}, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;
	stat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;
	homedir(): AbsolutePath;
}
export type UsingStatistics = {
	[key: string]: {
		name: string;
		referenceCount: number;
		ranges: Range[];
	};
};
export interface TokenLike {
	text: string;
	line: number;
	character: number;
	tokenIndex: number;
}
export interface _IFileIndex extends IFileIndex {
	usingStatistics: UsingStatistics;
	compilerVersion: string;
	compilerMessages: LSP.Diagnostic[];
	readonly workspaceVersion: number;
	_annotationDiagnostics: Readonly<LSP.Diagnostic[]>;
	plainStringTokens: IStringLiteralToken[];
	_statistics: IStatistics;
	readonly definitions: IExplicitDefinition[];
	_explicitNamespaces: {
		[absoluteName: string]: IExplicitDefinition;
	};
	_definitions: _IPositionIndex<IExplicitDefinition>;
	readonly _implicitDefinitions: ImplicitDefinitions;
	implicitDefinitionFor(fqn: string): IBuiltinDefinition | IFreeAnnotationDefinition | IImplicitNamespaceDefinition | undefined;
	definitionAt(position: LSP.Position, predicate?: (def: IExplicitDefinition) => boolean): IExplicitDefinition | undefined;
	tokens: IToken[];
	i18nStringTokens: IStringLiteralToken[];
	readonly uri: Uri;
	staleContent(): void;
	addRedefinition(redefinition: IExplicitDefinition, definition: IExplicitDefinition): void;
	identifierAt(position: LSP.Position): IIdentifierToken | undefined;
	addAnnotationAssignment(location: LSP.Location, embeddedAnnotation: string, carrier: IIdentifierToken, carrierName: string, carrierNameRange: LSP.Range): void;
	addReference(referenceToken: IGenericToken, definition: IGenericDefinition): void;
	redefinitionsFor(definition: IGenericDefinition): Generator<IExplicitDefinition, void, undefined>;
	referencesFor(definition: IGenericDefinition): Generator<IGenericToken, void, undefined>;
	clone(): _IFileIndex;
	correspondingStringTokens(text: string): IStringLiteralToken[];
	stringAt(position: LSP.Position): IStringLiteralToken | undefined;
	addIdentifierToken(token: TokenLike, mayRequireReorder?: boolean): IIdentifierToken;
}
export type DiagnosticSeverity = "Error" | "Warning" | "Info" | "Debug";
export interface CdsDidChangeConfigurationParams extends LSP.DidChangeConfigurationParams {
	settings: {
		cds?: {
			autoInstallDependencies?: boolean;
			compiler?: {
				markMissingI18nDefault?: boolean;
				showInternalErrors?: boolean;
			};
			completion?: {
				showDocumentation?: boolean;
				docFiles?: string[];
				annotations?: {
					omitRedundantTypesInSnippets?: boolean;
				};
			};
			contributions?: {
				registry?: string;
			};
			diagnosticsSeverity?: DiagnosticSeverity;
			trace?: {
				server?: "off" | "messages" | "verbose";
				components?: Array<{
					name: TraceComponentName;
					level: TraceLevel;
				}>;
				logfiles?: {
					count: number;
					maxSize: number;
				};
			};
			workspace?: {
				scanDependentModules: boolean;
			};
			workspaceSymbols?: {
				lazy: boolean;
			};
			workspaceValidationMode?: WorkspaceValidationMode;
		};
	};
}
export declare class ServerStarter {
	private readonly factory;
	static start(factory?: IFactory): void;
	private static createStarter;
	static assertRequiredNodeVersion(): void;
	private readonly tracer;
	protected constructor(factory: IFactory);
	private connect;
	private setupGlobalCdsHomePath;
	installEmergencyHooks(): void;
	protected createConnection(): IConnection<import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._, import("vscode-languageserver")._>;
}
declare const FormatOptionNames: readonly [
	"alignAfterKey",
	"alignAnnotations",
	"alignPreAnnotations",
	"alignPostAnnotations",
	"alignColonsInAnnotations",
	"alignValuesInAnnotations",
	"alignActionsAndFunctions",
	"alignActionNames",
	"alignActionReturns",
	"alignAs",
	"alignAsInEntities",
	"alignAsInSelectItems",
	"alignAsInUsing",
	"alignExpressionsAndConditions",
	"alignExprAndCondWithinBlock",
	"alignTypes",
	"alignColonsBeforeTypes",
	"alignEqualsAfterTypes",
	"alignTypesWithinBlock",
	"alignCompositionStructToRight",
	"cqlKeywordCapitalization",
	"keepPreAnnotationsInOriginalLine",
	"keepPostAnnotationsInOriginalLine",
	"keepEmptyBracketsTogether",
	"keepSingleLinedBlocksTogether",
	"keepOriginalEmptyLines",
	"maxKeepEmptyLines",
	"openingBraceInNewLine",
	"selectInNewLine",
	"tabSize",
	"finalNewline",
	"maxDocCommentLine",
	"whitespaceBeforeColon",
	"whitespaceBeforeColonInAnnotation",
	"whitespaceAfterColon",
	"whitespaceAfterColonInAnnotation",
	"whitespaceAfterComma",
	"whitespaceAroundAlignedOps",
	"whitespaceAroundBinaryOps",
	"whitespaceWithinBrackets",
	"cancelFormattingOnAlignmentDeadlocks"
];
export type FormatOptionName = typeof FormatOptionNames[number];
export type FormatOptionValue = boolean | number | string;
export interface IFormatOptionDefinition {
	readonly defaultValue: FormatOptionValue;
	readonly label: string;
	readonly description: string;
	readonly sampleCode: string;
	readonly parentDependency?: FormatOptionName;
	readonly isInternal: boolean;
	readonly allowedEnumValues: string[] | undefined;
	isValidValue(value: FormatOptionValue | null): value is FormatOptionValue;
}
export type IFormatOptionDefinitions = {
	[name in typeof FormatOptionNames[number]]: IFormatOptionDefinition;
};
export interface SchemaOption {
	label: string;
	type: "boolean" | "number" | "string";
	description: string;
	default: any;
	sample: string;
	category: "Alignment" | "Other" | "Whitespace";
	parentOption?: string;
	subOptions?: string[];
	enum?: string[];
}
export declare const FormatOptionDefinitions: IFormatOptionDefinitions;
declare const CDS_PRETTIER_JSON = ".cdsprettier.json";
export type CdsPrettierJson = typeof CDS_PRETTIER_JSON;
export interface FormatContentParams {
	command: "format";
	content: FileContent;
	formattingOptions: {
		[option: string]: boolean | string | number;
	};
}
export interface GetConfigParams {
	command: "config";
	sourcePath: Uri;
	projectPath: Uri;
}
export interface CdsLspPropertiesParams {
	name: "logfilePath";
}
export declare function formatCli(args?: string[], cwd?: string): Promise<void>;
export declare function ruleName(child: IRuleItem): BlockRule | undefined;

export {};

import * as LSP from 'vscode-languageserver-protocol';

export type Uri = string;
export type AbsolutePath = string;
export type WorkspaceRelativePath = string;
export type FileContent = string;
export type Kind = "context" | "service" | "namespace" | "entity" | "event" | "view" | "type" | "annotation" | "annotate" | "action" | "function" | "const" | "role" | "aspect" | "accesspolicy" | "mixin" | "element" | "query" | "param" | "enum" | "source" | "using" | "extend" | "qualifiedAnnotation";
export interface Thing {
	kind: XsnKind;
	name: XsnBaseName;
	location: XsnLocation;
	_artifact?: XsnArtifact;
	value?: XsnExtensionName;
	$duplicates?: boolean | Thing[];
}
export interface CdsvTextPosition {
	line: number;
	column: number;
}
export interface CdsvLocation {
	start: CdsvTextPosition;
	end: CdsvTextPosition;
	filename?: string;
}
export interface CdsvDefinitionName {
	absolute: string;
	id?: string;
	location?: CdsvLocation;
}
export interface WithLocation {
	location: XsnLocation;
}
export interface CdsvArtifact extends WithLocation {
	kind: CdsvKind;
	name: CdsvDefinitionName;
}
export interface CdsvDefinition extends CdsvArtifact {
	elements?: CdsvArtifact[];
	builtin?: boolean;
	internal?: boolean;
	expectedKind?: string;
	parameters?: string[];
	annotationAssignments?: any[];
	artifacts?: CdsvDefinitions;
	vocabularies?: CdsvDefinitions;
}
export type CsnSeverity = "Error" | "Warning" | "Info" | "Debug";
export interface XsnParseModel extends CdsvAstNode {
	dependencies?: Array<{
		location: XsnLocation;
		val: string;
	}>;
	options: CdsvParseOptions;
	tokens: unknown[];
	ruleTree: unknown;
	toolbox: IXsnToolbox;
}
export interface CdsvAstNodeName {
	id: string;
}
export interface CdsvAstNode {
	artifacts?: {
		[localName: string]: CdsvAstNode;
	};
	extensions?: CdsvAstNode[];
	elements?: CdsvAstNode[];
	name: CdsvAstNodeName;
	kind: CdsvKind;
	location: CdsvLocation;
	annotationAssignments?: XsnAnnotationAssignment[];
}
export interface CdsvDefinitions {
	[id: string]: CdsvDefinition;
}
export type CdsvKind = "context" | "entity" | "extend" | "element" | "namespace" | "using" | "service" | "source" | "type" | "view";
export interface CdsvParseOptions {
	parseOnly?: boolean;
	lintMode?: boolean;
	attachTokens?: boolean;
	ambigDetection?: boolean;
	fallbackParser?: string;
	messages: XsnMessage[];
	parseListener?: unknown;
}
export interface CdsvCompileOptions {
	fallbackParser?: "cds";
	attachValidNames?: boolean;
	attachTokens?: boolean;
	docComment?: boolean;
	messages?: XsnMessage[];
	parseListener?: unknown;
}
export interface ModuleOrigin {
	__loadedFrom: string;
	__logicalLocation: string;
}
export interface ICdsCompiler extends ModuleOrigin {
	parse(source: FileContent, filename: AbsolutePath, options?: CdsvParseOptions): XsnParseModel;
	compile(fileNames: AbsolutePath[], dir?: AbsolutePath, options?: CdsvCompileOptions, map?: CdsvSourceDictionary): Promise<XsnCompileModel>;
	version(): string;
	$lsp: ICdsCompiler;
	getArtifactName(thing: any): any;
	getSpecialFunctions?(): string[];
	createToolbox(): IXsnToolbox;
}
export interface CdsvSourceDictionary {
	[localPath: AbsolutePath]: FileContent;
}
export interface CsnDefinition {
	type?: CsnType;
	kind?: CsnKind;
	elements?: CsnStructuredType;
	items?: CsnArrayType;
	enum?: CsnEnum;
}
export type CsnKind = "entity" | "type" | "context" | "const" | "annotation" | "extend" | "annotate" | "define";
export type CsnType = unknown;
export interface CsnStructuredType {
	[localName: string]: CsnDefinition;
}
export interface CsnArrayType {
	type: CsnType;
}
export interface CsnEnum {
	[enumSymbol: string]: CsnEnumValue;
}
export interface CsnEnumValue {
	value?: null | boolean | number | string;
}
export interface XsnArtifacts {
	[localName: string]: XsnArtifact;
}
export interface XsnElements {
	[localName: string]: XsnElement;
}
export interface XsnSources {
	[absoluteLocalPath: AbsolutePath]: XsnSource;
}
export interface XsnCompileException {
	model?: XsnCompileModel;
	messages?: XsnMessage[];
	errors?: Array<{
		message: string;
	}>;
}
export type ResolutionStep = "ToDefinition" | "ToNextExplicitAlias";
export interface ResolutionOptions {
	step: ResolutionStep;
}
export interface IXsnToolbox {
	resolve(thing: any, options?: ResolutionOptions): any[];
	nameLocation(thing: any): XsnLocation | undefined;
	absoluteNameOf(thing: any): string | undefined;
	locationOf(thing: any): XsnLocation;
	originOf(thing: any): any;
	getKind(thing: Thing): Kind;
	expectedKindOf(thing: Thing): XsnKind;
	fullyQualifiedNameOf(thing: Thing): any;
	nameLocationOf(thing: any): XsnLocation | undefined;
	filterMessagesInScope(position: LSP.Position, message: XsnMessage, relativeProvokerPosition: number): boolean;
	queriesOf(t: any): XsnArtifact[];
	excludesOf(t: any): any;
	orderBys(t: any): any;
	sourcesOf(ast: XsnCompileModel): XsnSources;
	extract(model: XsnCompileModel, callback: IXsnExtraction): Error[];
	isImplicitNamespace(thing: any): boolean;
	isLocalizedInferred(artifact: any): boolean;
	isAutoexposed(thing: any): boolean;
	name(thing: any): XsnName;
	isReturnsCarrier(thing: any): boolean;
}
export interface XsnCompileModel {
	vocabularies?: XsnArtifacts;
	definitions: XsnArtifacts;
	sources: XsnSources;
	$sources: XsnSources;
	version: {
		creator: string;
		csn: string;
	};
	options: CdsvCompileOptions & {
		messages: XsnMessage[];
	};
	workspaceRoot: AbsolutePath;
	compilerVersion: string;
	compiler: ICdsCompiler;
	toolbox: IXsnToolbox;
}
export interface XsnMessage {
	home?: string;
	message: string;
	messageId?: string;
	expectedTokens?: string[];
	validNames?: {
		[id: string]: CdsvDefinition;
	};
	$location: XsnLocation;
	severity: CsnSeverity;
}
export interface XsnSource {
	vocabularies?: XsnArtifacts;
	kind: "source";
	filename: string;
	dirname: string;
	realname: string;
	artifacts: XsnArtifacts;
	dependencies: XsnFileDependency[];
	extensions: XsnExtension[];
	usings: XsnArtifactUsing[];
	tokens: unknown[];
	ruleTree?: unknown;
	options: CdsvCompileOptions;
	namespace?: XsnSourceNamespace;
}
export interface XsnSourceNamespace {
	path: Array<{
		id: string;
		location: XsnLocation;
	}>;
}
export type XsnKind = "__i18n" | "aspect" | "using" | "entity" | "view" | "annotation" | "annotate" | "context" | "type" | "element" | "extend" | "service" | "namespace" | "param" | "builtin" | "qualifiedAnnotation";
export type DollarInferred = "*" | "autoexposed" | "expand-element" | "include" | "localized" | "localized-entity" | "localized-texts" | "proxy" | "query";
export interface XsnArtifact {
	doc?: XsnDocComment;
	kind: XsnKind;
	annotationAssignments: XsnAnnotationAssignment[];
	extern?: {
		location: XsnLocation;
		path: XsnPathSegment[];
	};
	location: XsnLocation;
	name: XsnName;
	artifacts?: XsnArtifacts;
	$duplicates?: XsnArtifact[] | boolean;
	blocks?: Array<{
		kind: "block";
		annotationAssignments: XsnAnnotationAssignment[];
		artifacts: XsnArtifacts;
		location: XsnLocation;
		name: XsnName;
	}>;
	elements?: XsnElements;
	enum?: XsnElements;
	actions?: XsnElements;
	returns?: any;
	params?: XsnElements;
	includes?: XsnArtifact[];
	queries?: XsnArtifact[];
	$queries?: XsnArtifact[];
	extensions?: XsnExtension[];
	$inferred?: DollarInferred;
	localized?: any;
	builtin?: boolean;
	vocabularies?: XsnArtifacts;
}
export interface XsnAnnotationAssignment {
	kind?: "annotate";
	location: XsnLocation;
	name: XsnExtensionName;
	value?: XsnFileDependency;
	val?: string;
	path?: XsnPathSegment[];
	symbol?: {
		id: string;
		location: XsnLocation;
	};
}
export interface XsnFileDependency {
	literal: string;
	location: XsnLocation;
	realname?: string;
	val: string;
}
export type XsnExtension = XsnExtendExtension | XsnAnnotateExtension;
export interface XsnExtendExtension {
	kind: "extend";
	expectedKind?: "service" | "context" | "entity" | "type" | "aspect" | "element";
	annotationAssignments: XsnAnnotationAssignment[];
	elements: XsnElements;
	location: XsnLocation;
	name: XsnExtensionName;
	artifacts?: XsnArtifacts;
}
export interface XsnAnnotateExtension {
	kind: "annotate";
	annotationAssignments: XsnAnnotationAssignment[];
	actions?: XsnElements;
	elements?: XsnElements;
	location: XsnLocation;
	name: XsnExtensionName;
	artifacts?: XsnArtifacts;
}
export interface XsnDocComment {
	val: string;
	location: XsnLocation;
}
export interface XsnElement {
	doc?: XsnDocComment;
	kind: "element";
	elements?: XsnElements;
	annotationAssignments: XsnAnnotationAssignment[];
	indexNo: number;
	location: XsnLocation;
	name: XsnElementName;
	type: XsnExtensionElementType;
	target?: XsnExtensionElementType;
	returns?: XsnExtensionElementType;
	$inferred?: DollarInferred;
}
export interface XsnElementName {
	absolute: string;
	element: string;
	id: string;
	location: XsnLocation;
}
export interface XsnExtensionElementType {
	absolute: string;
	location: XsnLocation;
	path: XsnPathSegment[];
	scope: number;
	_artifact?: Thing;
}
export interface XsnArtifactUsing {
	kind: "using";
	fileDep?: XsnFileDependency;
	annotationAssignments: XsnAnnotationAssignment[];
	extern?: {
		location: XsnLocation;
		path: XsnPathSegment[];
	};
	location: XsnLocation;
	name: XsnName;
	usings?: XsnArtifactUsing[];
}
export interface XsnBaseName {
	absolute: string;
	id: string;
	$inferred?: DollarInferred;
	location: XsnLocation;
	path?: XsnPathSegment[];
}
export interface XsnExtensionName extends XsnBaseName {
	location: XsnLocation;
	path: XsnPathSegment[];
	_artifact?: Thing;
}
export interface XsnName extends XsnBaseName {
	absolute: string;
	calculated?: boolean;
	action?: string;
	param?: string;
	element?: string;
	id: string;
	$inferred?: DollarInferred;
	location: XsnLocation;
	path?: XsnPathSegment[];
	query?: number;
	_artifact?: Thing;
}
export interface XsnLocation {
	file: WorkspaceRelativePath;
	line: number;
	col: number;
	endLine: number;
	endCol: number;
	$weak?: boolean;
}
export interface XsnPosition {
	line: number;
	column: number;
}
export interface XsnPathSegment {
	id: string;
	location: XsnLocation;
	_artifact?: Thing;
}
export interface IXsnExtraction {
	onTokensFound<IPpToken>(absoluteLocalPath: AbsolutePath, tokens: IPpToken[], compilerVersion: string): void;
	onMessagesFound(model: XsnCompileModel, relativePath: WorkspaceRelativePath, messages: XsnMessage[]): void;
	onDefinitionFound(event: IXsnDefinitionEvent): void;
	onReferenceFound(event: IXsnReferenceEvent): void;
	onReferencesDone(event: IXsnExtractionEvent): void;
	onDirectDependenciesFound(absoluteLocalPath: string, dependentAbsoluteLocalPaths: string[]): void;
}
export interface IXsnExtractionEvent {
	compiler: ICdsCompiler;
	consumed: boolean;
	toolbox: IXsnToolbox;
	model?: XsnCompileModel;
}
export interface IXsnDefinitionEvent extends IXsnExtractionEvent {
	thing: any;
	fullyQualifiedName: string;
}
export interface IXsnReferenceEvent extends IXsnExtractionEvent {
	thing: any;
	hint?: string;
}
export type AutoCreationMode = "create" | "noCreate" | "warnCreate";
export interface IAnnotationAssignmentToken extends IGenericToken {
	readonly carrier: IIdentifierToken;
	readonly carrierName: string;
	readonly carrierNameRange?: LSP.Range;
}
export interface IGenericToken extends LSP.Position {
	readonly uri: Uri;
	readonly tokenIndex: number;
	readonly text: string;
	readonly annotationValue?: string;
	readonly range: LSP.Range;
	readonly location: LSP.Location;
	compare(position: LSP.Position): number;
}
export interface IStringLiteralToken extends IGenericToken {
	translationId?: string;
	isUsingPath?: boolean;
}
export interface IGenericDefinition {
	readonly symbolName: string;
	readonly fullyQualifiedName: string;
	readonly kind: XsnKind;
	readonly absoluteName: string;
}
export interface IIdentifierToken extends IGenericToken {
	readonly definitions?: IGenericDefinition | IGenericDefinition[];
}
export interface IFileIndex {
	idTokens: IIdentifierToken[];
	directDependentUris: string[];
	readonly annotationAssignments: IterableIterator<IAnnotationAssignmentToken>;
}
export interface IExplicitDefinition extends IGenericDefinition, LSP.Position {
	location: LSP.Location;
	nameLocation: LSP.Location;
	line: number;
	character: number;
	docComment?: string;
	isExtend?: boolean;
}
export interface IBlitzIndex {
	readonly builtUris: readonly string[];
	getTransitiveDependencies(uri: string): Set<string>;
	forUri(uri: string, create?: undefined | "create" | "warnCreate"): IFileIndex;
	forUri(uri: string, create: "noCreate"): IFileIndex | undefined;
}
export interface IContribution {
	initialize?: (context: IContributionContext) => Promise<void>;
}
export declare enum Setting {
	MarkMissingTranslations = "cds.compiler.markMissingI18nDefault",
	OmitRedundantTypesInSnippets = "cds.completion.annotations.omitRedundantTypesInSnippets"
}
export interface Translation {
	uri: string;
	line: number;
	character: number;
	id: string;
	text: string;
}
export interface ITranslationProvider {
	resolve(sourceUri: string, translationId: string): Translation | undefined;
}
export interface ISettingsProvider {
	get(setting: Setting): unknown;
}
export interface IContributionContext {
	trace: IContributionTracer;
	translation: ITranslationProvider;
	settings: ISettingsProvider;
}
export type ContributionTraceMessage = () => string;
export interface IContributionTracer {
	debug(m: ContributionTraceMessage): void;
	verbose(m: ContributionTraceMessage): void;
	info(m: ContributionTraceMessage): void;
	warn(m: ContributionTraceMessage): void;
	error(m: ContributionTraceMessage): void;
}
export interface IAnnotationContribution extends IContribution {
	fetchCompletions?: (params: CdsCompletionParams) => Promise<CdsCompletionItem[]>;
	fetchDiagnostics?: (params: CdsDiagnosticParams) => Promise<CdsDiagnostics>;
	fetchQuickfixes?: (params: LSP.CodeActionParams) => Promise<CdsQuickfix[]>;
	fetchHover?: (params: CdsHoverParams) => Promise<CdsHover | undefined>;
	fetchDefinition?: (params: CdsDefinitionParams) => Promise<LSP.Location | LSP.Location[] | undefined>;
	fetchReferences?: (params: CdsDefinitionParams) => Promise<LSP.Location[]>;
	fetchSemanticTokens?: (params: CdsSemanticTokensParams) => Promise<SemanticToken[]>;
	indexAnnotationIdentifiers?: (params: CdsIndexingParams) => Promise<CdsAnnotationIndex>;
	indexAndValidate?: (params: CdsIndexingParams) => Promise<CdsAnnotationIndexAndDiagnostics>;
}
export interface CdsIndexingParams {
	uris: Uri[];
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsAnnotationIndexEntry {
	absoluteName: string;
	definition: LSP.Location;
	references: LSP.Location[];
}
export type CdsDiagnostics = Map<Uri, LSP.Diagnostic[]>;
export type CdsAnnotationIndex = CdsAnnotationIndexEntry[];
export interface CdsAnnotationIndexAndDiagnostics {
	annotationIndex: CdsAnnotationIndex;
	diagnostics: CdsDiagnostics;
}
export type CdsQuickfix = Omit<LSP.CodeAction, "command">;
export interface CdsCompletionParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	index: IBlitzIndex;
	annotation: IAnnotationAssignmentToken;
	ast: XsnCompileModel;
	relativeLocalPath: string;
	isCompoundAnnotation: boolean;
}
export interface CdsDiagnosticParams {
	uris: Uri[];
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsHoverParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	annotation: IAnnotationAssignmentToken;
	index: IBlitzIndex;
}
export interface CdsDefinitionParams {
	cursorPosition: LSP.TextDocumentPositionParams;
	annotation: IAnnotationAssignmentToken;
	index: IBlitzIndex;
	ast: XsnCompileModel;
}
export interface CdsHover extends LSP.Hover {
	contents: CdsMarkupContent;
}
export interface CdsMarkupContent extends LSP.MarkupContent {
	kind: "markdown";
}
export interface CdsCompletionItem extends LSP.CompletionItem {
	data?: unknown;
}
export interface CdsSemanticTokensParams {
	uri: Uri;
	index: IBlitzIndex;
}
export interface SemanticToken {
	line: number;
	character: number;
	length: number;
	tokenType: LSP.SemanticTokenTypes;
	tokenModifiers: LSP.SemanticTokenModifiers[];
}

export {};
